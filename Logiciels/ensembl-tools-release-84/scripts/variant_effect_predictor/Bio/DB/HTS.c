/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.30 from the
 * contents of HTS.xs. Do not edit this file, edit HTS.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "lib/Bio/DB/HTS.xs"
/*
Copyright [1999-2016] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifdef PERL_CAPI
#define WIN32IO_IS_STDIO
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef FCGI
 #include <fcgi_stdio.h>
#else
 #ifdef USE_SFIO
  #include <config.h>
 #else
  #include <stdio.h>
 #endif
 #include <perlio.h>
#endif

#ifndef Newx
#  define Newx(v,n,t) New(0,v,n,t)
#endif

#ifndef Newxz
#  define Newxz(v,n,t) Newz(0,v,n,t)
#endif

#include <unistd.h>
#include <math.h>
#include <string.h>
#include "kseq.h"
#include "hts.h"
#include "sam.h"
#include "khash.h"
#include "faidx.h"
#include "tbx.h"
#include "bgzf.h"
#include "vcf.h"
#include "synced_bcf_reader.h"

/* stolen from bam_aux.c */
#define BAM_MAX_REGION 1<<29

typedef htsFile*        Bio__DB__HTSfile;
typedef bam_hdr_t*      Bio__DB__HTS__Header;
typedef bam1_t*         Bio__DB__HTS__Alignment;
typedef hts_idx_t*      Bio__DB__HTS__Index;
typedef faidx_t*        Bio__DB__HTS__Fai;
typedef bam_pileup1_t*  Bio__DB__HTS__Pileup;
typedef tbx_t*          Bio__DB__HTS__Tabix;
typedef hts_itr_t*      Bio__DB__HTS__Tabix__Iterator;
typedef bcf_srs_t*      Bio__DB__HTS__VCF;
typedef bcf_hdr_t*      Bio__DB__HTS__VCF__Header;
typedef bcf1_t*         Bio__DB__HTS__VCF__Row;


typedef struct {
  SV* callback;
  SV* data;
} fetch_callback_data;
typedef fetch_callback_data *fetch_callback_dataptr;
typedef struct {
  int    start;
  int    end;
  double width;
  int    reads;
  int*   bin;
} coverage_graph;
typedef coverage_graph *coverage_graph_ptr;

static int MaxPileupCnt=8000;

void XS_pack_charPtrPtr( SV * arg, char ** array, int count) {
  int i;
  AV * avref;
  avref = (AV*)sv_2mortal((SV*)newAV());
  for (i=0; i<count; i++) {
    av_push(avref, newSVpv(array[i], strlen(array[i])));
  }
  SvSetSV( arg, newRV((SV*)avref));
}

int hts_fetch_fun (void *data, bam1_t *b)
{
  dSP;
  int count;

  fetch_callback_dataptr fcp;
  SV* callback;
  SV* callbackdata;
  SV* alignment_obj;
  bam1_t *b2;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam1_t into an appropriate object */
  /* need to dup it here so that the C layer doesn't reuse the address under Perl */
  b2 = bam_dup1(b);

  alignment_obj = sv_setref_pv(newSV(sizeof(bam1_t)),"Bio::DB::HTS::Alignment",(void*) b2);

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(alignment_obj));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;

  return 1;
}

int invoke_pileup_callback_fun(uint32_t tid,
			       uint32_t pos,
			       int n,
			       const bam_pileup1_t *pl,
			       void *data) {
  dSP;
  int count,i;
  fetch_callback_dataptr fcp;
  SV*  callback;
  SV*  callbackdata;
  SV*  pileup_obj;
  SV* p;
  SV** pileups;
  AV*  pileup;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam_pileup1_t into the appropriate object */
  /* this causes a compiler warning -- ignore it */
  pileup = newAV();
  av_extend(pileup,n);
  for (i=0;i<n;i++) {
    p = newSV(sizeof(bam_pileup1_t));
    sv_setref_pv(p,"Bio::DB::HTS::Pileup",(void*) &pl[i]);
    av_push(pileup,p);
  }

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(newSViv(tid)));
  XPUSHs(sv_2mortal(newSViv(pos)));
  XPUSHs(sv_2mortal(newRV_noinc((SV*)pileup)));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;
}

/*
   Declarations to allow add_pileup_line to work
   Ported from samtoosl v1 setup.
*/

/* start pileup support copy from bam.h in samtools */
/* but pileup functions are offered as bam_plp_auto_f in htslib */

typedef int (*bam_pileup_f)(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pl, void *data);

typedef struct
{
  bam_plp_t iter;
  bam_pileup_f func;
  void *data;
} hts_plbuf_t;


hts_plbuf_t *hts_plbuf_init(bam_pileup_f func, void *data)
{
    hts_plbuf_t *buf;
    buf = calloc(1, sizeof(hts_plbuf_t));
    buf->iter = bam_plp_init(0, 0);
    buf->func = func;
    buf->data = data;
    return buf;
}

void hts_plbuf_destroy(hts_plbuf_t *buf)
{
    bam_plp_destroy(buf->iter);
    free(buf);
}

int hts_plbuf_push(const bam1_t *b, hts_plbuf_t *buf)
{
    int ret, n_plp, tid, pos;
    const bam_pileup1_t *plp;
    ret = bam_plp_push(buf->iter, b);
    if (ret < 0) return ret;
    while ((plp = bam_plp_next(buf->iter, &tid, &pos, &n_plp)) != 0)
        buf->func(tid, pos, n_plp, plp, buf->data);
    return 0;
}


/* end pileup support copy from bam.h in samtools */

/**
   pileup support functions
*/
int add_pileup_line (void *data, bam1_t *b)
{
  hts_plbuf_t *pileup = (hts_plbuf_t*) data;
  hts_plbuf_push(b,pileup);
  return 0;
}



int coverage_from_pileup_fun (uint32_t tid,
			      uint32_t pos,
			      int n,
			      const bam_pileup1_t *pl,
			      void *data) {
  coverage_graph_ptr  cgp;
  int                 bin;
  int                 i;
  int                 valid;

  cgp = (coverage_graph_ptr) data;
  cgp->reads += n;

  valid = 0;
  for (i=0;i<n;i++) {
    if (!pl[i].is_del && !pl[i].is_refskip)
        valid++;
  }

  if (pos >= cgp->start && pos <= cgp->end) {
    bin = (pos-cgp->start)/cgp->width;
    cgp->bin[bin] += valid;
  }

  return 0;
}


/**
   From bam_aux.c in samtools. Needed to allow pileup function to work.
*/
int bam_parse_region(bam_hdr_t *header, const char *str, int *ref_id, int *beg, int *end)
{
    const char *name_lim = hts_parse_reg(str, beg, end);
    if (name_lim) {
        char *name = malloc(name_lim - str + 1);
        memcpy(name, str, name_lim - str);
        name[name_lim - str] = '\0';
        *ref_id = bam_name2id(header, name);
        free(name);
    }
    else {
        // not parsable as a region, but possibly a sequence named "foo:a"
        *ref_id = bam_name2id(header, str);
        *beg = 0; *end = INT_MAX;
    }
    if (*ref_id == -1) return -1;
    return *beg <= *end? 0 : -1;
}

/**
   From bam.c in samtools - these are wrappers that can be used OK here.
*/
char *bam_format1(const bam_hdr_t *header, const bam1_t *b)
{
    kstring_t str;
    str.l = str.m = 0; str.s = NULL;
    sam_format1(header, b, &str);
    return str.s;
}


void bam_view1(const bam_hdr_t *header, const bam1_t *b)
{
        char *s = bam_format1(header, b);
        puts(s);
        free(s);
}


/**
   Get the file extension for a filename
*/
int get_index_fmt_from_extension(const char * filename)
{
  char * ext = strrchr( filename, '.' ) ;
  if( strcmp(ext, ".cram")==0 )
  {
    return HTS_FMT_CRAI ;
  }
  if( strcmp(ext, ".bam")==0 )
  {
    return HTS_FMT_BAI ; //could also be HTS_FMT_CSI
  }
  return -1 ;
}

/**
   fetch function
*/
int hts_fetch(htsFile *fp, const hts_idx_t *idx, int tid, int beg, int end, void *data, bam_plp_auto_f func)
{
    int ret;
    hts_itr_t *iter ;
    bam1_t *b ;

    iter = sam_itr_queryi(idx, tid, beg, end);
    b = bam_init1();

    while((ret = sam_itr_next(fp, iter, b)) >= 0)
    {
        func(data,b);
    }
    hts_itr_destroy(iter);
    bam_destroy1(b);
    return (ret == -1)? 0 : ret;
}




#line 364 "lib/Bio/DB/HTS.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 508 "lib/Bio/DB/HTS.c"

XS_EUPXS(XS_Bio__DB__HTS__Fai_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_load)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"Bio::DB::HTS::Fai\", filename");
    {
	char *	packname;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__Fai	RETVAL;

	if (items < 1)
	    packname = "Bio::DB::HTS::Fai";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 362 "lib/Bio/DB/HTS.xs"
    RETVAL = fai_load(filename);
#line 530 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Fai", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Fai_destroy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_destroy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fai");
    {
	Bio__DB__HTS__Fai	fai;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Fai")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__HTS__Fai,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Fai::destroy",
			"fai", "Bio::DB::HTS::Fai")
;
#line 371 "lib/Bio/DB/HTS.xs"
    fai_destroy(fai);
#line 562 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Fai_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_fetch)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fai, reg");
    {
	Bio__DB__HTS__Fai	fai;
	const char *	reg = (const char *)SvPV_nolen(ST(1))
;
#line 379 "lib/Bio/DB/HTS.xs"
    char     *seq;
    int       len;
#line 581 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Fai")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__HTS__Fai,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Fai::fetch",
			"fai", "Bio::DB::HTS::Fai")
;
#line 382 "lib/Bio/DB/HTS.xs"
    seq = fai_fetch(fai,reg,&len);
    if (seq == NULL)
       XSRETURN_EMPTY;
    RETVAL = newSVpv(seq,len);
    free((void*)seq);
#line 599 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_max_pileup_cnt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_max_pileup_cnt)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "packname, ...");
    {
	int	RETVAL;
	dXSTARG;
#line 396 "lib/Bio/DB/HTS.xs"
	if (items > 1)
	   MaxPileupCnt = SvIV(ST(1));
	RETVAL = MaxPileupCnt;
#line 620 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_open)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "packname, filename, mode=\"r\"");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	char *	mode;
	Bio__DB__HTSfile	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 410 "lib/Bio/DB/HTS.xs"
        RETVAL = hts_open(filename,mode);
#line 649 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTSfile", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "htsfile");
    {
	Bio__DB__HTSfile	htsfile;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::close",
			"htsfile", "Bio::DB::HTSfile")
;
#line 420 "lib/Bio/DB/HTS.xs"
   hts_close(htsfile);
#line 681 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTSfile_index_build); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_index_build)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	const char *	filename = (const char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 428 "lib/Bio/DB/HTS.xs"
     RETVAL = sam_index_build(filename,0); //generate BAI for BAM files
#line 702 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_index_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_index_load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, htsfile");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Index	RETVAL;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::index_load",
			"htsfile", "Bio::DB::HTSfile")
;
#line 440 "lib/Bio/DB/HTS.xs"
      RETVAL = sam_index_load(htsfile, htsfile->fn) ;
#line 732 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Index", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_index_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_index_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "indexfile");
    {
	Bio__DB__HTS__Index	indexfile;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    indexfile = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::index_close",
			"indexfile", "Bio::DB::HTS::Index")
;
#line 449 "lib/Bio/DB/HTS.xs"
      hts_idx_destroy(indexfile) ;
#line 764 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTSfile_header_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_header_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "htsfile");
    {
	Bio__DB__HTSfile	htsfile;
#line 458 "lib/Bio/DB/HTS.xs"
      bam_hdr_t *bh;
      int64_t result ;
#line 781 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_read",
			"htsfile", "Bio::DB::HTSfile")
;
#line 461 "lib/Bio/DB/HTS.xs"
      if( htsfile->format.format == bam ) //enum value from htsExactFormat from hts.h
      {
        result = bgzf_seek(htsfile->fp.bgzf,0,0) ;
      }
      bh = sam_hdr_read(htsfile);
      RETVAL = bh ;
#line 800 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_header_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_header_write)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hts, header");
    {
	Bio__DB__HTSfile	hts;
	Bio__DB__HTS__Header	header;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hts = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_write",
			"hts", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_write",
			"header", "Bio::DB::HTS::Header")
;
#line 477 "lib/Bio/DB/HTS.xs"
      RETVAL= sam_hdr_write(hts,header);
#line 845 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_read1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_read1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "htsfile, header");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
#line 488 "lib/Bio/DB/HTS.xs"
    bam1_t *alignment;
#line 863 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::read1",
			"htsfile", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::read1",
			"header", "Bio::DB::HTS::Header")
;
#line 490 "lib/Bio/DB/HTS.xs"
       alignment = bam_init1();
       if (sam_read1(htsfile,header,alignment) >= 0) {
         RETVAL = alignment ;
       }
       else
         XSRETURN_EMPTY;
#line 892 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_new)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "package=\"Bio::DB::HTS::Alignment\"");
    {
	char *	package;
	Bio__DB__HTS__Alignment	RETVAL;

	if (items < 1)
	    package = "Bio::DB::HTS::Alignment";
	else {
	    package = (char *)SvPV_nolen(ST(0))
;
	}
#line 507 "lib/Bio/DB/HTS.xs"
      RETVAL = bam_init1();
#line 922 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Alignment::DESTROY",
			"b")
;
#line 516 "lib/Bio/DB/HTS.xs"
    bam_destroy1(b);
#line 954 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_tid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_tid)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::tid",
			"b", "Bio::DB::HTS::Alignment")
;
#line 523 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.tid = SvIV(ST(1));
    RETVAL=b->core.tid;
#line 984 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_pos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::pos",
			"b", "Bio::DB::HTS::Alignment")
;
#line 534 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.pos = SvIV(ST(1));
    RETVAL=b->core.pos;
#line 1015 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_calend); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_calend)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::calend",
			"b", "Bio::DB::HTS::Alignment")
;
#line 545 "lib/Bio/DB/HTS.xs"
   RETVAL=bam_endpos(b);
#line 1044 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar2qlen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar2qlen)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::cigar2qlen",
			"b", "Bio::DB::HTS::Alignment")
;
#line 554 "lib/Bio/DB/HTS.xs"
   RETVAL=bam_cigar2qlen(b->core.n_cigar,bam_get_cigar(b));
#line 1073 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qual); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qual)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qual",
			"b", "Bio::DB::HTS::Alignment")
;
#line 563 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.qual = SvIV(ST(1));
    RETVAL=b->core.qual;
#line 1104 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_flag); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_flag)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::flag",
			"b", "Bio::DB::HTS::Alignment")
;
#line 574 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.flag = SvIV(ST(1));
    RETVAL=b->core.flag;
#line 1135 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_n_cigar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_n_cigar)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::n_cigar",
			"b", "Bio::DB::HTS::Alignment")
;
#line 585 "lib/Bio/DB/HTS.xs"
  if (items > 1)
    b->core.n_cigar = SvIV(ST(1));
    RETVAL=b->core.n_cigar;
#line 1166 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_qseq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_qseq)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::l_qseq",
			"b", "Bio::DB::HTS::Alignment")
;
#line 596 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.l_qseq = SvIV(ST(1));
    RETVAL=b->core.l_qseq;
#line 1197 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qseq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qseq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 607 "lib/Bio/DB/HTS.xs"
    char* seq;
    int   i;
#line 1215 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qseq",
			"b", "Bio::DB::HTS::Alignment")
;
#line 610 "lib/Bio/DB/HTS.xs"
    seq = Newxz(seq,b->core.l_qseq+1,char);
    for (i=0;i<b->core.l_qseq;i++) {
      seq[i]=seq_nt16_str[bam_seqi(bam_get_seq(b),i)];
    }
    RETVAL = newSVpv(seq,b->core.l_qseq);
    Safefree(seq);
#line 1234 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment__qscore); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment__qscore)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::_qscore",
			"b", "Bio::DB::HTS::Alignment")
;
#line 624 "lib/Bio/DB/HTS.xs"
    RETVAL = newSVpv(bam_get_qual(b),b->core.l_qseq);
#line 1263 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mtid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mtid)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mtid",
			"b", "Bio::DB::HTS::Alignment")
;
#line 633 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.mtid = SvIV(ST(1));
    RETVAL=b->core.mtid;
#line 1295 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mpos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mpos",
			"b", "Bio::DB::HTS::Alignment")
;
#line 644 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.mpos = SvIV(ST(1));
    RETVAL=b->core.mpos;
#line 1326 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_isize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_isize)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::isize",
			"b", "Bio::DB::HTS::Alignment")
;
#line 655 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.isize = SvIV(ST(1));
    RETVAL=b->core.isize;
#line 1357 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_aux); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_aux)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::l_aux",
			"b", "Bio::DB::HTS::Alignment")
;
#line 666 "lib/Bio/DB/HTS.xs"
    RETVAL=SvIV(newSViv(bam_get_l_aux(b)));
#line 1386 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 674 "lib/Bio/DB/HTS.xs"
   uint8_t *s;
   uint8_t type, key[2];
   char    str[8192];
#line 1405 "lib/Bio/DB/HTS.c"
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux",
			"b", "Bio::DB::HTS::Alignment")
;
#line 678 "lib/Bio/DB/HTS.xs"
   s = bam_get_aux(b);
   str[0] = '\0';

   int left  = sizeof(str) - strlen(str);
   while (left > 0 && (s < b->data + b->l_data)) {
        char* d   = str+strlen(str);

	key[0] = s[0];
	key[1] = s[1];
 	left -= snprintf(d, left, "%c%c:", key[0], key[1]);

	d    += 3;
	s    += 2;
	type = *s++;

	if (left <= 0) continue;

	if (type == 'A')      { left -= snprintf(d, left, "A:%c", *s);           s++; }
	else if (type == 'C') { left -= snprintf(d, left, "i:%u", *s);           s++; }
	else if (type == 'c') { left -= snprintf(d, left, "i:%d", *s);           s++; }
	else if (type == 'S') { left -= snprintf(d, left, "i:%u", *(uint16_t*)s);s += 2; }
	else if (type == 's') { left -= snprintf(d, left, "i:%d", *(int16_t*)s); s += 2; }
	else if (type == 'I') { left -= snprintf(d, left, "i:%u", *(uint32_t*)s);s += 4; }
	else if (type == 'i') { left -= snprintf(d, left, "i:%d", *(int32_t*)s); s += 4; }
	else if (type == 'f') { left -= snprintf(d, left, "f:%g", *(float*)s);   s += 4; }
	else if (type == 'd') { left -= snprintf(d, left, "d:%lg", *(double*)s); s += 8; }
	else if (type == 'Z' || type == 'H') { left -= snprintf(d, left, "%c:", type);
	                                       strncat(d,s,left);
					       while (*s++) {}
					       left = sizeof(str) - strlen(str);
	                                     }
	if (left <= 0) continue;
	strncat(d,"\t",left);
	left--;
   }
   str[strlen(str)-1] = '\0';
   RETVAL = str;
#line 1456 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, tag");
    {
	Bio__DB__HTS__Alignment	b;
	char*	tag = (char *)SvPV_nolen(ST(1))
;
#line 724 "lib/Bio/DB/HTS.xs"
   int           type;
   uint8_t       *s;
#line 1476 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux_get",
			"b", "Bio::DB::HTS::Alignment")
;
#line 727 "lib/Bio/DB/HTS.xs"
   s    = bam_aux_get(b,tag);
   if (s==0)
      XSRETURN_EMPTY;
   type = *s++;
   switch (type) {
   case 'c':
     RETVAL = newSViv((int32_t)*(int8_t*)s);
     break;
   case 'C':
     RETVAL = newSViv((int32_t)*(uint8_t*)s);
     break;
   case 's':
     RETVAL = newSViv((int32_t)*(int16_t*)s);
     break;
   case 'S':
     RETVAL = newSViv((int32_t)*(uint16_t*)s);
     break;
   case 'i':
     RETVAL = newSViv(*(int32_t*)s);
     break;
   case 'I':
     RETVAL = newSViv((int32_t)*(uint32_t*)s);
     break;
   case 'f':
     RETVAL = newSVnv(*(float*)s);
     break;
   case 'Z':
   case 'H':
     RETVAL = newSVpv((char*)s,0);
     break;
   case 'A':
     RETVAL = newSVpv((char*)s,1);
     break;
   default:
     XSRETURN_EMPTY;
   }
#line 1525 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_keys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_keys)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__HTS__Alignment	b;
#line 771 "lib/Bio/DB/HTS.xs"
   uint8_t *s;
   uint8_t type;
#line 1546 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux_keys",
			"b", "Bio::DB::HTS::Alignment")
;
#line 774 "lib/Bio/DB/HTS.xs"
   {
     s = bam_get_aux(b);  /* s is a khash macro */
     while (s < b->data + b->l_data) {
       XPUSHs(sv_2mortal(newSVpv(s,2)));
       s   += 2;
       type = *s++;
       if      (type == 'A') { ++s; }
       else if (type == 'C') { ++s; }
       else if (type == 'c') { ++s; }
       else if (type == 'S') { s += 2; }
       else if (type == 's') { s += 2; }
       else if (type == 'I') { s += 4; }
       else if (type == 'i') { s += 4; }
       else if (type == 'f') { s += 4; }
       else if (type == 'Z' || type == 'H') { while (*s) ++(s); ++(s); }
     }
   }
#line 1575 "lib/Bio/DB/HTS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_data)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
#line 797 "lib/Bio/DB/HTS.xs"
    STRLEN  len;
#line 1592 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::data",
			"b", "Bio::DB::HTS::Alignment")
;
#line 799 "lib/Bio/DB/HTS.xs"
    if (items > 1) {
      b->data     = SvPV(ST(1),len);
      b->l_data = len;
    }
    RETVAL=newSVpv(b->data,b->l_data);
#line 1610 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_data_len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_data_len)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::data_len",
			"b", "Bio::DB::HTS::Alignment")
;
#line 812 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->l_data = SvIV(ST(1));
    RETVAL=b->l_data;
#line 1642 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_m_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_m_data)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::m_data",
			"b", "Bio::DB::HTS::Alignment")
;
#line 823 "lib/Bio/DB/HTS.xs"
    if (items > 1) {
      b->m_data = SvIV(ST(1));
    }
    RETVAL=b->m_data;
#line 1674 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qname",
			"b", "Bio::DB::HTS::Alignment")
;
#line 835 "lib/Bio/DB/HTS.xs"
    RETVAL=newSVpv(bam_get_qname(b),0);
#line 1702 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_paired); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_paired)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::paired",
			"b", "Bio::DB::HTS::Alignment")
;
#line 844 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FPAIRED) != 0;
#line 1732 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_proper_pair); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_proper_pair)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::proper_pair",
			"b", "Bio::DB::HTS::Alignment")
;
#line 853 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FPROPER_PAIR) != 0;
#line 1761 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_unmapped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_unmapped)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::unmapped",
			"b", "Bio::DB::HTS::Alignment")
;
#line 862 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FUNMAP) != 0;
#line 1790 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_munmapped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_munmapped)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::munmapped",
			"b", "Bio::DB::HTS::Alignment")
;
#line 871 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FMUNMAP) != 0;
#line 1819 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_reversed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_reversed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::reversed",
			"b", "Bio::DB::HTS::Alignment")
;
#line 880 "lib/Bio/DB/HTS.xs"
  RETVAL=bam_is_rev(b);
#line 1848 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mreversed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mreversed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mreversed",
			"b", "Bio::DB::HTS::Alignment")
;
#line 889 "lib/Bio/DB/HTS.xs"
  RETVAL=bam_is_mrev(b);
#line 1877 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 898 "lib/Bio/DB/HTS.xs"
    int        i;
    uint32_t  *c;
    AV        *avref;
#line 1896 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::cigar",
			"b", "Bio::DB::HTS::Alignment")
;
#line 902 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    c     = bam_get_cigar(b);
    for (i=0;i<b->core.n_cigar;i++)
      av_push(avref, newSViv(c[i]));
    RETVAL = (SV*) newRV((SV*)avref);
#line 1914 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_new)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=Bio::DB::HTS::Header");
    {
	Bio__DB__HTS__Header	RETVAL;
#line 916 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_hdr_init();
#line 1932 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_n_targets); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_n_targets)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::n_targets",
			"bamh", "Bio::DB::HTS::Header")
;
#line 925 "lib/Bio/DB/HTS.xs"
    RETVAL = bamh->n_targets;
#line 1966 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_target_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_target_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
#line 934 "lib/Bio/DB/HTS.xs"
    int i;
    AV * avref;
#line 1984 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::target_name",
			"bamh", "Bio::DB::HTS::Header")
;
#line 937 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
      av_push(avref, newSVpv(bamh->target_name[i],0));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2001 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_target_len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_target_len)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
#line 949 "lib/Bio/DB/HTS.xs"
    int i;
    AV * avref;
#line 2020 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::target_len",
			"bamh", "Bio::DB::HTS::Header")
;
#line 952 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
       av_push(avref, newSViv(bamh->target_len[i]));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2037 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_text); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_text)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "bamh, ...");
    {
	Bio__DB__HTS__Header	bamh;
#line 963 "lib/Bio/DB/HTS.xs"
    char   *newtext;
    STRLEN n;
#line 2056 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::text",
			"bamh", "Bio::DB::HTS::Header")
;
#line 966 "lib/Bio/DB/HTS.xs"
    /* in case text is not null terminated, we copy it */
    RETVAL = newSVpv(bamh->text,bamh->l_text);
    if (items > 1) {
      newtext = (char*) SvPV(ST(1),n);
      strcpy(bamh->text,newtext);
      bamh->l_text = n;
    }
#line 2076 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_parse_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_parse_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bamh, region");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__HTS__Header	bamh;
	char*	region = (char *)SvPV_nolen(ST(1))
;
#line 983 "lib/Bio/DB/HTS.xs"
       int seqid,start,end;
#line 2098 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::parse_region",
			"bamh", "Bio::DB::HTS::Header")
;
#line 985 "lib/Bio/DB/HTS.xs"
    {
      bam_parse_region(bamh,
		       region,
		       &seqid,
		       &start,
		       &end);
      if (seqid < 0)
	XSRETURN_EMPTY;
      else {
	EXTEND(sp,3);
	PUSHs(sv_2mortal(newSViv(seqid)));
	PUSHs(sv_2mortal(newSViv(start)));
	PUSHs(sv_2mortal(newSViv(end)));
      }
    }
#line 2125 "lib/Bio/DB/HTS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Bio__DB__HTS__Header_view1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_view1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bamh, alignment");
    {
	Bio__DB__HTS__Header	bamh;
	Bio__DB__HTS__Alignment	alignment;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::view1",
			"bamh", "Bio::DB::HTS::Header")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    alignment = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::view1",
			"alignment", "Bio::DB::HTS::Alignment")
;
#line 1007 "lib/Bio/DB/HTS.xs"
       bam_view1(bamh,alignment);
#line 2163 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Header_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Header::DESTROY",
			"bamh")
;
#line 1015 "lib/Bio/DB/HTS.xs"
    bam_hdr_destroy(bamh);
#line 2189 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Index_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_fetch)
{
    dVAR; dXSARGS;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	CV*	callback;
	SV*	callbackdata;
#line 1031 "lib/Bio/DB/HTS.xs"
  fetch_callback_data fcd;
#line 2214 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::fetch",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::fetch",
			"hfp", "Bio::DB::HTSfile")
;

	STMT_START {
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = ST(5);
		SvGETMAGIC(xsub_tmp_sv);
                callback = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!callback) {
		    Perl_croak(aTHX_ "%s: %s is not a CODE reference",
				"Bio::DB::HTS::Index::fetch",
				"callback");
		}
	} STMT_END
;

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6)
;
	}
#line 1033 "lib/Bio/DB/HTS.xs"
  {
    fcd.callback = (SV*) callback;
    fcd.data     = callbackdata;
    RETVAL = hts_fetch(hfp,bai,ref,start,end,&fcd,hts_fetch_fun);
  }
#line 2264 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Index_pileup); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_pileup)
{
    dVAR; dXSARGS;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	CV*	callback;
	SV*	callbackdata;
#line 1052 "lib/Bio/DB/HTS.xs"
  fetch_callback_data fcd;
  hts_plbuf_t        *pileup;
#line 2291 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::pileup",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::pileup",
			"hfp", "Bio::DB::HTSfile")
;

	STMT_START {
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = ST(5);
		SvGETMAGIC(xsub_tmp_sv);
                callback = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!callback) {
		    Perl_croak(aTHX_ "%s: %s is not a CODE reference",
				"Bio::DB::HTS::Index::pileup",
				"callback");
		}
	} STMT_END
;

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6)
;
	}
#line 1055 "lib/Bio/DB/HTS.xs"
  fcd.callback = (SV*) callback;
  fcd.data     = callbackdata;
  pileup       = hts_plbuf_init(invoke_pileup_callback_fun,(void*)&fcd);
  bam_plp_set_maxcnt(pileup->iter,MaxPileupCnt);
  hts_fetch(hfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
  hts_plbuf_push(NULL,pileup);
  hts_plbuf_destroy(pileup);
#line 2341 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Index_coverage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_coverage)
{
    dVAR; dXSARGS;
    if (items < 5 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, bins=0, maxcnt=8000");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	int	bins;
	int	maxcnt;
#line 1073 "lib/Bio/DB/HTS.xs"
    coverage_graph  cg;
    hts_plbuf_t    *pileup;
    AV*             array;
    SV*             cov;
    int             i;
    bam_hdr_t      *bh;
#line 2371 "lib/Bio/DB/HTS.c"
	AV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::coverage",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::coverage",
			"hfp", "Bio::DB::HTSfile")
;

	if (items < 6)
	    bins = 0;
	else {
	    bins = (int)SvIV(ST(5))
;
	}

	if (items < 7)
	    maxcnt = 8000;
	else {
	    maxcnt = (int)SvIV(ST(6))
;
	}
#line 1080 "lib/Bio/DB/HTS.xs"
  {
      /* TODO:can we do away with this check by a move to CSI as the standard for BAM indices */
      if (end >= BAM_MAX_REGION)
      {
        if( hfp->format.format == bam ) //enum value from htsExactFormat from hts.h
        {
          bgzf_seek(hfp->fp.bgzf,0,0);
          bh = sam_hdr_read(hfp);
          end = bh->target_len[ref];
          bam_hdr_destroy(bh);
        }
      }
      if ((bins==0) || (bins > (end-start)))
         bins = end-start;

      /* coverage graph used to communicate to our callback
	  the region we are sampling */
      cg.start = start;
      cg.end   = end;
      cg.reads = 0;
      cg.width = ((double)(end-start))/bins;
      Newxz(cg.bin,bins+1,int);

      /* accumulate coverage into the coverage graph */
      pileup   = hts_plbuf_init(coverage_from_pileup_fun,(void*)&cg);
      if (items >= 7)
            bam_plp_set_maxcnt(pileup->iter,maxcnt);
      else
            bam_plp_set_maxcnt(pileup->iter,MaxPileupCnt);
      hts_fetch(hfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
      hts_plbuf_push(NULL,pileup);
      hts_plbuf_destroy(pileup);

      /* now normalize to coverage/bp and convert into an array */
      array = newAV();
      av_extend(array,bins);
      for  (i=0;i<bins;i++)
           av_store(array,i,newSVnv(((float)cg.bin[i])/cg.width));
      Safefree(cg.bin);
      RETVAL = array;
      sv_2mortal((SV*)RETVAL);  /* this fixes a documented bug in perl typemap */
  }
#line 2450 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Index_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hts_idx");
    {
	Bio__DB__HTS__Index	hts_idx;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hts_idx = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::close",
			"hts_idx", "Bio::DB::HTS::Index")
;
#line 1130 "lib/Bio/DB/HTS.xs"
    hts_idx_destroy(hts_idx) ;
#line 2482 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_qpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_qpos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::qpos",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1140 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->qpos;
#line 2510 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_pos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::pos",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1148 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->qpos+1;
#line 2539 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_indel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_indel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::indel",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1156 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->indel;
#line 2568 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_level); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_level)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::level",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1164 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->level;
#line 2597 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_del); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_del)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_del",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1172 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_del;
#line 2626 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_refskip); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_refskip)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_refskip",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1180 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_refskip;
#line 2655 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_head); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_head)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_head",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1188 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_head;
#line 2684 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_tail); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_tail)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_tail",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1196 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_tail;
#line 2713 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_b); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_b)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::b",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1204 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_dup1(pl->b);
#line 2741 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_alignment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_alignment)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::alignment",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1212 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_dup1(pl->b);
#line 2774 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_open)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fname");
    {
	char *	fname = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTS__Tabix	RETVAL;
#line 1224 "lib/Bio/DB/HTS.xs"
    RETVAL = tbx_index_load(fname);
#line 2798 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Tabix", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "t");
    {
	Bio__DB__HTS__Tabix	t;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_close",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1233 "lib/Bio/DB/HTS.xs"
    tbx_destroy(t);
#line 2830 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_query); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_query)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "t, region");
    {
	Bio__DB__HTS__Tabix	t;
	char *	region = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__Tabix__Iterator	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_query",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1241 "lib/Bio/DB/HTS.xs"
    RETVAL = tbx_itr_querys(t, region);
#line 2859 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Tabix::Iterator", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_header); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_header)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fp, tabix");
    {
	Bio__DB__HTSfile	fp;
	Bio__DB__HTS__Tabix	tabix;
#line 1252 "lib/Bio/DB/HTS.xs"
    int num_header_lines = 0;
    AV *av_ref;
    kstring_t str = {0,0,0};
#line 2884 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_header",
			"fp", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    tabix = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_header",
			"tabix", "Bio::DB::HTS::Tabix")
;
#line 1256 "lib/Bio/DB/HTS.xs"
    av_ref = newAV();
    while ( hts_getline(fp, KS_SEP_LINE, &str) >= 0 ) {
        if ( ! str.l ) break; //no lines left so we are done
        if ( str.s[0] != tabix->conf.meta_char ) break;

        //the line begins with a # so add it to the array
        ++num_header_lines;
        av_push(av_ref, newSVpv(str.s, str.l));
    }

    if ( ! num_header_lines )
        XSRETURN_EMPTY;

    RETVAL = newRV_noinc((SV*) av_ref);
#line 2921 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_seqnames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_seqnames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "t");
    {
	Bio__DB__HTS__Tabix	t;
#line 1277 "lib/Bio/DB/HTS.xs"
    const char **names;
    int i, num_seqs;
    AV *av_ref;
#line 2941 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_seqnames",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1281 "lib/Bio/DB/HTS.xs"
    names = tbx_seqnames(t, &num_seqs); //call actual tabix method

    //blast all the values onto a perl array
    av_ref = newAV();
    for (i = 0; i < num_seqs; ++i) {
        SV *sv_ref = newSVpv(names[i], 0);
        av_push(av_ref, sv_ref);
    }

    free(names);

    //return a reference to our array
    RETVAL = newRV_noinc((SV*)av_ref);
#line 2967 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "iter, fp, t");
    {
	Bio__DB__HTS__Tabix__Iterator	iter;
	Bio__DB__HTSfile	fp;
	Bio__DB__HTS__Tabix	t;
#line 1305 "lib/Bio/DB/HTS.xs"
    kstring_t str = {0,0,0};
#line 2987 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__Tabix__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"iter", "Bio::DB::HTS::Tabix::Iterator")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    fp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"fp", "Bio::DB::HTSfile")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1307 "lib/Bio/DB/HTS.xs"
    if (tbx_itr_next(fp, t, iter, &str) < 0)
        XSRETURN_EMPTY;

    RETVAL = newSVpv(str.s, str.l);
#line 3024 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "iter");
    {
	Bio__DB__HTS__Tabix__Iterator	iter;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__Tabix__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_free",
			"iter", "Bio::DB::HTS::Tabix::Iterator")
;
#line 1318 "lib/Bio/DB/HTS.xs"
	tbx_itr_destroy(iter);
#line 3052 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF_bcf_sr_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF_bcf_sr_open)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "filename");
    {
	char*	filename = (char *)SvPV_nolen(ST(0))
;
#line 1327 "lib/Bio/DB/HTS.xs"
        bcf_srs_t* sr = bcf_sr_init();
#line 3069 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF	RETVAL;
#line 1329 "lib/Bio/DB/HTS.xs"
        bcf_sr_add_reader(sr, filename);
        RETVAL = sr;
#line 3074 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF_bcf_header); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF_bcf_header)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vcf");
    {
	Bio__DB__HTS__VCF	vcf;
#line 1339 "lib/Bio/DB/HTS.xs"
        bcf_hdr_t* h;
#line 3096 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vcf = INT2PTR(Bio__DB__HTS__VCF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::bcf_header",
			"vcf", "Bio::DB::HTS::VCF")
;
#line 1341 "lib/Bio/DB/HTS.xs"
        h = vcf->readers[0].header;
        RETVAL = h;
#line 3111 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF_bcf_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF_bcf_next)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vcf");
    {
	Bio__DB__HTS__VCF	vcf;
#line 1351 "lib/Bio/DB/HTS.xs"
        bcf1_t* line;
#line 3133 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Row	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vcf = INT2PTR(Bio__DB__HTS__VCF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::bcf_next",
			"vcf", "Bio::DB::HTS::VCF")
;
#line 1353 "lib/Bio/DB/HTS.xs"
        if ( bcf_sr_next_line(vcf) ) {
            line = bcf_sr_get_line(vcf, 0); //0 being the first and only reader
            RETVAL = line;
        }
        else {
            XSRETURN_EMPTY;
        }
#line 3153 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Row", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF_bcf_num_variants); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF_bcf_num_variants)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vcf");
    {
	Bio__DB__HTS__VCF	vcf;
#line 1368 "lib/Bio/DB/HTS.xs"
        int n_records = 0;
#line 3175 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vcf = INT2PTR(Bio__DB__HTS__VCF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::bcf_num_variants",
			"vcf", "Bio::DB::HTS::VCF")
;
#line 1370 "lib/Bio/DB/HTS.xs"
        //loop through all the lines but don't do anything with them
        while ( bcf_sr_next_line(vcf) ) {
            ++n_records;
        }

        RETVAL = newSViv(n_records);
#line 3194 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF_bcf_sr_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF_bcf_sr_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vcf");
    {
	Bio__DB__HTS__VCF	vcf;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vcf = INT2PTR(Bio__DB__HTS__VCF,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::bcf_sr_close",
			"vcf", "Bio::DB::HTS::VCF")
;
#line 1384 "lib/Bio/DB/HTS.xs"
        bcf_sr_destroy(vcf);
#line 3222 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Bio__DB__HTS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Bio__DB__HTS)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("Bio::DB::HTS::Fai::load", XS_Bio__DB__HTS__Fai_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::destroy", XS_Bio__DB__HTS__Fai_destroy, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::fetch", XS_Bio__DB__HTS__Fai_fetch, file, "$$$");
        newXS_deffile("Bio::DB::HTSfile::max_pileup_cnt", XS_Bio__DB__HTSfile_max_pileup_cnt);
        (void)newXSproto_portable("Bio::DB::HTSfile::open", XS_Bio__DB__HTSfile_open, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::close", XS_Bio__DB__HTSfile_close, file, "$");
        newXS_deffile("Bio::DB::HTSfile::index_build", XS_Bio__DB__HTSfile_index_build);
        (void)newXSproto_portable("Bio::DB::HTSfile::index_load", XS_Bio__DB__HTSfile_index_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::index_close", XS_Bio__DB__HTSfile_index_close, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::header_read", XS_Bio__DB__HTSfile_header_read, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::header_write", XS_Bio__DB__HTSfile_header_write, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::read1", XS_Bio__DB__HTSfile_read1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::new", XS_Bio__DB__HTS__Alignment_new, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::DESTROY", XS_Bio__DB__HTS__Alignment_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::tid", XS_Bio__DB__HTS__Alignment_tid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::pos", XS_Bio__DB__HTS__Alignment_pos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::calend", XS_Bio__DB__HTS__Alignment_calend, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::cigar2qlen", XS_Bio__DB__HTS__Alignment_cigar2qlen, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qual", XS_Bio__DB__HTS__Alignment_qual, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::flag", XS_Bio__DB__HTS__Alignment_flag, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::n_cigar", XS_Bio__DB__HTS__Alignment_n_cigar, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::l_qseq", XS_Bio__DB__HTS__Alignment_l_qseq, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qseq", XS_Bio__DB__HTS__Alignment_qseq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::_qscore", XS_Bio__DB__HTS__Alignment__qscore, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mtid", XS_Bio__DB__HTS__Alignment_mtid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mpos", XS_Bio__DB__HTS__Alignment_mpos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::isize", XS_Bio__DB__HTS__Alignment_isize, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::l_aux", XS_Bio__DB__HTS__Alignment_l_aux, file, "$;$");
        newXS_deffile("Bio::DB::HTS::Alignment::aux", XS_Bio__DB__HTS__Alignment_aux);
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::aux_get", XS_Bio__DB__HTS__Alignment_aux_get, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::aux_keys", XS_Bio__DB__HTS__Alignment_aux_keys, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::data", XS_Bio__DB__HTS__Alignment_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::data_len", XS_Bio__DB__HTS__Alignment_data_len, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::m_data", XS_Bio__DB__HTS__Alignment_m_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qname", XS_Bio__DB__HTS__Alignment_qname, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::paired", XS_Bio__DB__HTS__Alignment_paired, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::proper_pair", XS_Bio__DB__HTS__Alignment_proper_pair, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::unmapped", XS_Bio__DB__HTS__Alignment_unmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::munmapped", XS_Bio__DB__HTS__Alignment_munmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::reversed", XS_Bio__DB__HTS__Alignment_reversed, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mreversed", XS_Bio__DB__HTS__Alignment_mreversed, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::cigar", XS_Bio__DB__HTS__Alignment_cigar, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::new", XS_Bio__DB__HTS__Header_new, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::n_targets", XS_Bio__DB__HTS__Header_n_targets, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::target_name", XS_Bio__DB__HTS__Header_target_name, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::target_len", XS_Bio__DB__HTS__Header_target_len, file, "$");
        newXS_deffile("Bio::DB::HTS::Header::text", XS_Bio__DB__HTS__Header_text);
        (void)newXSproto_portable("Bio::DB::HTS::Header::parse_region", XS_Bio__DB__HTS__Header_parse_region, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::view1", XS_Bio__DB__HTS__Header_view1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::DESTROY", XS_Bio__DB__HTS__Header_DESTROY, file, "$");
        newXS_deffile("Bio::DB::HTS::Index::fetch", XS_Bio__DB__HTS__Index_fetch);
        newXS_deffile("Bio::DB::HTS::Index::pileup", XS_Bio__DB__HTS__Index_pileup);
        newXS_deffile("Bio::DB::HTS::Index::coverage", XS_Bio__DB__HTS__Index_coverage);
        newXS_deffile("Bio::DB::HTS::Index::close", XS_Bio__DB__HTS__Index_close);
        newXS_deffile("Bio::DB::HTS::Pileup::qpos", XS_Bio__DB__HTS__Pileup_qpos);
        newXS_deffile("Bio::DB::HTS::Pileup::pos", XS_Bio__DB__HTS__Pileup_pos);
        newXS_deffile("Bio::DB::HTS::Pileup::indel", XS_Bio__DB__HTS__Pileup_indel);
        newXS_deffile("Bio::DB::HTS::Pileup::level", XS_Bio__DB__HTS__Pileup_level);
        newXS_deffile("Bio::DB::HTS::Pileup::is_del", XS_Bio__DB__HTS__Pileup_is_del);
        newXS_deffile("Bio::DB::HTS::Pileup::is_refskip", XS_Bio__DB__HTS__Pileup_is_refskip);
        newXS_deffile("Bio::DB::HTS::Pileup::is_head", XS_Bio__DB__HTS__Pileup_is_head);
        newXS_deffile("Bio::DB::HTS::Pileup::is_tail", XS_Bio__DB__HTS__Pileup_is_tail);
        newXS_deffile("Bio::DB::HTS::Pileup::b", XS_Bio__DB__HTS__Pileup_b);
        newXS_deffile("Bio::DB::HTS::Pileup::alignment", XS_Bio__DB__HTS__Pileup_alignment);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_open", XS_Bio__DB__HTS__Tabix_tbx_open);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_close", XS_Bio__DB__HTS__Tabix_tbx_close);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_query", XS_Bio__DB__HTS__Tabix_tbx_query);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_header", XS_Bio__DB__HTS__Tabix_tbx_header);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_seqnames", XS_Bio__DB__HTS__Tabix_tbx_seqnames);
        newXS_deffile("Bio::DB::HTS::Tabix::Iterator::tbx_iter_next", XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next);
        newXS_deffile("Bio::DB::HTS::Tabix::Iterator::tbx_iter_free", XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free);
        newXS_deffile("Bio::DB::HTS::VCF::bcf_sr_open", XS_Bio__DB__HTS__VCF_bcf_sr_open);
        newXS_deffile("Bio::DB::HTS::VCF::bcf_header", XS_Bio__DB__HTS__VCF_bcf_header);
        newXS_deffile("Bio::DB::HTS::VCF::bcf_next", XS_Bio__DB__HTS__VCF_bcf_next);
        newXS_deffile("Bio::DB::HTS::VCF::bcf_num_variants", XS_Bio__DB__HTS__VCF_bcf_num_variants);
        newXS_deffile("Bio::DB::HTS::VCF::bcf_sr_close", XS_Bio__DB__HTS__VCF_bcf_sr_close);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

