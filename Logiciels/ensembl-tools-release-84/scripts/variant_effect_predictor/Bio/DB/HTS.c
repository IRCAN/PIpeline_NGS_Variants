/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.30 from the
 * contents of HTS.xs. Do not edit this file, edit HTS.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "lib/Bio/DB/HTS.xs"
/*
Copyright [1999-2016] EMBL-European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifdef PERL_CAPI
#define WIN32IO_IS_STDIO
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef FCGI
 #include <fcgi_stdio.h>
#else
 #ifdef USE_SFIO
  #include <config.h>
 #else
  #include <stdio.h>
 #endif
 #include <perlio.h>
#endif

#ifndef Newx
#  define Newx(v,n,t) New(0,v,n,t)
#endif

#ifndef Newxz
#  define Newxz(v,n,t) Newz(0,v,n,t)
#endif

#include <unistd.h>
#include <math.h>
#include <string.h>
#include "kseq.h"
#include "hts.h"
#include "sam.h"
#include "khash.h"
#include "faidx.h"
#include "tbx.h"
#include "bgzf.h"
#include "vcf.h"
#include "vcfutils.h"
#include "vcf_sweep.h"
#include "synced_bcf_reader.h"
#include <zlib.h>

/* stolen from bam_aux.c */
#define BAM_MAX_REGION 1<<29

typedef htsFile*        Bio__DB__HTSfile;
typedef bam_hdr_t*      Bio__DB__HTS__Header;
typedef bam1_t*         Bio__DB__HTS__Alignment;
typedef hts_idx_t*      Bio__DB__HTS__Index;
typedef faidx_t*        Bio__DB__HTS__Fai;
typedef bam_pileup1_t*  Bio__DB__HTS__Pileup;
typedef tbx_t*          Bio__DB__HTS__Tabix;
typedef hts_itr_t*      Bio__DB__HTS__Tabix__Iterator;
typedef vcfFile*        Bio__DB__HTS__VCFfile;
typedef bcf_hdr_t*      Bio__DB__HTS__VCF__Header;
typedef bcf1_t*         Bio__DB__HTS__VCF__Row;
KSEQ_INIT(gzFile, gzread)
typedef gzFile          Bio__DB__HTS__Kseq;
typedef kseq_t*         Bio__DB__HTS__Kseq__Iterator;
typedef kstream_t*      Bio__DB__HTS__Kseq__Kstream;
typedef kstring_t*      Bio__DB__HTS__Kseq__Kstring;
typedef bcf_sweep_t*    Bio__DB__HTS__VCF__Sweep;

typedef struct {
  SV* callback;
  SV* data;
} fetch_callback_data;
typedef fetch_callback_data *fetch_callback_dataptr;
typedef struct {
  int    start;
  int    end;
  double width;
  int    reads;
  int*   bin;
} coverage_graph;
typedef coverage_graph *coverage_graph_ptr;

static int MaxPileupCnt=8000;

void XS_pack_charPtrPtr( SV * arg, char ** array, int count) {
  int i;
  AV * avref;
  avref = (AV*)sv_2mortal((SV*)newAV());
  for (i=0; i<count; i++) {
    av_push(avref, newSVpv(array[i], strlen(array[i])));
  }
  SvSetSV( arg, newRV((SV*)avref));
}

int hts_fetch_fun (void *data, bam1_t *b)
{
  dSP;
  int count;

  fetch_callback_dataptr fcp;
  SV* callback;
  SV* callbackdata;
  SV* alignment_obj;
  bam1_t *b2;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam1_t into an appropriate object */
  /* need to dup it here so that the C layer doesn't reuse the address under Perl */
  b2 = bam_dup1(b);

  alignment_obj = sv_setref_pv(newSV(sizeof(bam1_t)),"Bio::DB::HTS::Alignment",(void*) b2);

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(alignment_obj));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;

  return 1;
}

int invoke_pileup_callback_fun(uint32_t tid,
			       uint32_t pos,
			       int n,
			       const bam_pileup1_t *pl,
			       void *data) {
  dSP;
  int count,i;
  fetch_callback_dataptr fcp;
  SV*  callback;
  SV*  callbackdata;
  SV*  pileup_obj;
  SV* p;
  SV** pileups;
  AV*  pileup;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam_pileup1_t into the appropriate object */
  /* this causes a compiler warning -- ignore it */
  pileup = newAV();
  av_extend(pileup,n);
  for (i=0;i<n;i++) {
    p = newSV(sizeof(bam_pileup1_t));
    sv_setref_pv(p,"Bio::DB::HTS::Pileup",(void*) &pl[i]);
    av_push(pileup,p);
  }

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(newSViv(tid)));
  XPUSHs(sv_2mortal(newSViv(pos)));
  XPUSHs(sv_2mortal(newRV_noinc((SV*)pileup)));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;
}

/*
   Declarations to allow add_pileup_line to work
   Ported from samtoosl v1 setup.
*/

/* start pileup support copy from bam.h in samtools */
/* but pileup functions are offered as bam_plp_auto_f in htslib */

typedef int (*bam_pileup_f)(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pl, void *data);

typedef struct
{
  bam_plp_t iter;
  bam_pileup_f func;
  void *data;
} hts_plbuf_t;


hts_plbuf_t *hts_plbuf_init(bam_pileup_f func, void *data)
{
    hts_plbuf_t *buf;
    buf = calloc(1, sizeof(hts_plbuf_t));
    buf->iter = bam_plp_init(0, 0);
    buf->func = func;
    buf->data = data;
    return buf;
}

void hts_plbuf_destroy(hts_plbuf_t *buf)
{
    bam_plp_destroy(buf->iter);
    free(buf);
}

int hts_plbuf_push(const bam1_t *b, hts_plbuf_t *buf)
{
    int ret, n_plp, tid, pos;
    const bam_pileup1_t *plp;
    ret = bam_plp_push(buf->iter, b);
    if (ret < 0) return ret;
    while ((plp = bam_plp_next(buf->iter, &tid, &pos, &n_plp)) != 0)
        buf->func(tid, pos, n_plp, plp, buf->data);
    return 0;
}


/* end pileup support copy from bam.h in samtools */

/**
   pileup support functions
*/
int add_pileup_line (void *data, bam1_t *b)
{
  hts_plbuf_t *pileup = (hts_plbuf_t*) data;
  hts_plbuf_push(b,pileup);
  return 0;
}



int coverage_from_pileup_fun (uint32_t tid,
			      uint32_t pos,
			      int n,
			      const bam_pileup1_t *pl,
			      void *data) {
  coverage_graph_ptr  cgp;
  int                 bin;
  int                 i;
  int                 valid;

  cgp = (coverage_graph_ptr) data;
  cgp->reads += n;

  valid = 0;
  for (i=0;i<n;i++) {
    if (!pl[i].is_del && !pl[i].is_refskip)
        valid++;
  }

  if (pos >= cgp->start && pos <= cgp->end) {
    bin = (pos-cgp->start)/cgp->width;
    cgp->bin[bin] += valid;
  }

  return 0;
}


/**
   From bam_aux.c in samtools. Needed to allow pileup function to work.
*/
int bam_parse_region(bam_hdr_t *header, const char *str, int *ref_id, int *beg, int *end)
{
    const char *name_lim = hts_parse_reg(str, beg, end);
    if (name_lim) {
        char *name = malloc(name_lim - str + 1);
        memcpy(name, str, name_lim - str);
        name[name_lim - str] = '\0';
        *ref_id = bam_name2id(header, name);
        free(name);
    }
    else {
        // not parsable as a region, but possibly a sequence named "foo:a"
        *ref_id = bam_name2id(header, str);
        *beg = 0; *end = INT_MAX;
    }
    if (*ref_id == -1) return -1;
    return *beg <= *end? 0 : -1;
}

/**
   From bam.c in samtools - these are wrappers that can be used OK here.
*/
char *bam_format1(const bam_hdr_t *header, const bam1_t *b)
{
    kstring_t str;
    str.l = str.m = 0; str.s = NULL;
    sam_format1(header, b, &str);
    return str.s;
}


void bam_view1(const bam_hdr_t *header, const bam1_t *b)
{
        char *s = bam_format1(header, b);
        puts(s);
        free(s);
}


/**
   Get the file extension for a filename
*/
int get_index_fmt_from_extension(const char * filename)
{
  char * ext = strrchr( filename, '.' ) ;
  if( strcmp(ext, ".cram")==0 )
  {
    return HTS_FMT_CRAI ;
  }
  if( strcmp(ext, ".bam")==0 )
  {
    return HTS_FMT_BAI ; //could also be HTS_FMT_CSI
  }
  return -1 ;
}

/**
   fetch function
*/
int hts_fetch(htsFile *fp, const hts_idx_t *idx, int tid, int beg, int end, void *data, bam_plp_auto_f func)
{
    int ret;
    hts_itr_t *iter ;
    bam1_t *b ;

    iter = sam_itr_queryi(idx, tid, beg, end);
    b = bam_init1();

    while((ret = sam_itr_next(fp, iter, b)) >= 0)
    {
        func(data,b);
    }
    hts_itr_destroy(iter);
    bam_destroy1(b);
    return (ret == -1)? 0 : ret;
}




#line 372 "lib/Bio/DB/HTS.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 516 "lib/Bio/DB/HTS.c"

XS_EUPXS(XS_Bio__DB__HTS__Fai_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_load)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"Bio::DB::HTS::Fai\", filename");
    {
	char *	packname;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__Fai	RETVAL;

	if (items < 1)
	    packname = "Bio::DB::HTS::Fai";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 370 "lib/Bio/DB/HTS.xs"
    RETVAL = fai_load(filename);
#line 538 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Fai", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Fai_destroy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_destroy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fai");
    {
	Bio__DB__HTS__Fai	fai;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Fai")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__HTS__Fai,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Fai::destroy",
			"fai", "Bio::DB::HTS::Fai")
;
#line 379 "lib/Bio/DB/HTS.xs"
    fai_destroy(fai);
#line 570 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Fai_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_fetch)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fai, reg");
    {
	Bio__DB__HTS__Fai	fai;
	const char *	reg = (const char *)SvPV_nolen(ST(1))
;
#line 387 "lib/Bio/DB/HTS.xs"
    char     *seq;
    int       len;
#line 589 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Fai")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__HTS__Fai,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Fai::fetch",
			"fai", "Bio::DB::HTS::Fai")
;
#line 390 "lib/Bio/DB/HTS.xs"
    seq = fai_fetch(fai,reg,&len);
    if (seq == NULL)
       XSRETURN_EMPTY;
    RETVAL = newSVpv(seq,len);
    free((void*)seq);
#line 607 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_max_pileup_cnt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_max_pileup_cnt)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "packname, ...");
    {
	int	RETVAL;
	dXSTARG;
#line 404 "lib/Bio/DB/HTS.xs"
	if (items > 1)
	   MaxPileupCnt = SvIV(ST(1));
	RETVAL = MaxPileupCnt;
#line 628 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_open)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "packname, filename, mode=\"r\"");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	char *	mode;
	Bio__DB__HTSfile	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 418 "lib/Bio/DB/HTS.xs"
        RETVAL = hts_open(filename,mode);
#line 657 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTSfile", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "htsfile");
    {
	Bio__DB__HTSfile	htsfile;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::close",
			"htsfile", "Bio::DB::HTSfile")
;
#line 428 "lib/Bio/DB/HTS.xs"
   hts_close(htsfile);
#line 689 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTSfile_index_build); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_index_build)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	const char *	filename = (const char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 436 "lib/Bio/DB/HTS.xs"
     RETVAL = sam_index_build(filename,0); //generate BAI for BAM files
#line 710 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_index_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_index_load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, htsfile");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Index	RETVAL;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::index_load",
			"htsfile", "Bio::DB::HTSfile")
;
#line 448 "lib/Bio/DB/HTS.xs"
      RETVAL = sam_index_load(htsfile, htsfile->fn) ;
#line 740 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Index", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_index_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_index_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "indexfile");
    {
	Bio__DB__HTS__Index	indexfile;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    indexfile = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::index_close",
			"indexfile", "Bio::DB::HTS::Index")
;
#line 457 "lib/Bio/DB/HTS.xs"
      hts_idx_destroy(indexfile) ;
#line 772 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTSfile_header_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_header_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "htsfile");
    {
	Bio__DB__HTSfile	htsfile;
#line 466 "lib/Bio/DB/HTS.xs"
      bam_hdr_t *bh;
      int64_t result ;
#line 789 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_read",
			"htsfile", "Bio::DB::HTSfile")
;
#line 469 "lib/Bio/DB/HTS.xs"
      if( htsfile->format.format == bam ) //enum value from htsExactFormat from hts.h
      {
        result = bgzf_seek(htsfile->fp.bgzf,0,0) ;
      }
      bh = sam_hdr_read(htsfile);
      RETVAL = bh ;
#line 808 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_header_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_header_write)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hts, header");
    {
	Bio__DB__HTSfile	hts;
	Bio__DB__HTS__Header	header;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hts = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_write",
			"hts", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_write",
			"header", "Bio::DB::HTS::Header")
;
#line 485 "lib/Bio/DB/HTS.xs"
      RETVAL= sam_hdr_write(hts,header);
#line 853 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_read1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_read1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "htsfile, header");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
#line 496 "lib/Bio/DB/HTS.xs"
    bam1_t *alignment;
#line 871 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::read1",
			"htsfile", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTSfile::read1",
			"header", "Bio::DB::HTS::Header")
;
#line 498 "lib/Bio/DB/HTS.xs"
       alignment = bam_init1();
       if (sam_read1(htsfile,header,alignment) >= 0) {
         RETVAL = alignment ;
       }
       else
         XSRETURN_EMPTY;
#line 900 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_new)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "package=\"Bio::DB::HTS::Alignment\"");
    {
	char *	package;
	Bio__DB__HTS__Alignment	RETVAL;

	if (items < 1)
	    package = "Bio::DB::HTS::Alignment";
	else {
	    package = (char *)SvPV_nolen(ST(0))
;
	}
#line 515 "lib/Bio/DB/HTS.xs"
      RETVAL = bam_init1();
#line 930 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Alignment::DESTROY",
			"b")
;
#line 524 "lib/Bio/DB/HTS.xs"
    bam_destroy1(b);
#line 962 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_tid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_tid)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::tid",
			"b", "Bio::DB::HTS::Alignment")
;
#line 531 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.tid = SvIV(ST(1));
    RETVAL=b->core.tid;
#line 992 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_pos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::pos",
			"b", "Bio::DB::HTS::Alignment")
;
#line 542 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.pos = SvIV(ST(1));
    RETVAL=b->core.pos;
#line 1023 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_calend); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_calend)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::calend",
			"b", "Bio::DB::HTS::Alignment")
;
#line 553 "lib/Bio/DB/HTS.xs"
   RETVAL=bam_endpos(b);
#line 1052 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar2qlen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar2qlen)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::cigar2qlen",
			"b", "Bio::DB::HTS::Alignment")
;
#line 562 "lib/Bio/DB/HTS.xs"
   RETVAL=bam_cigar2qlen(b->core.n_cigar,bam_get_cigar(b));
#line 1081 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qual); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qual)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qual",
			"b", "Bio::DB::HTS::Alignment")
;
#line 571 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.qual = SvIV(ST(1));
    RETVAL=b->core.qual;
#line 1112 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_flag); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_flag)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::flag",
			"b", "Bio::DB::HTS::Alignment")
;
#line 582 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.flag = SvIV(ST(1));
    RETVAL=b->core.flag;
#line 1143 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_n_cigar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_n_cigar)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::n_cigar",
			"b", "Bio::DB::HTS::Alignment")
;
#line 593 "lib/Bio/DB/HTS.xs"
  if (items > 1)
    b->core.n_cigar = SvIV(ST(1));
    RETVAL=b->core.n_cigar;
#line 1174 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_qseq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_qseq)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::l_qseq",
			"b", "Bio::DB::HTS::Alignment")
;
#line 604 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.l_qseq = SvIV(ST(1));
    RETVAL=b->core.l_qseq;
#line 1205 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qseq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qseq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 615 "lib/Bio/DB/HTS.xs"
    char* seq;
    int   i;
#line 1223 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qseq",
			"b", "Bio::DB::HTS::Alignment")
;
#line 618 "lib/Bio/DB/HTS.xs"
    seq = Newxz(seq,b->core.l_qseq+1,char);
    for (i=0;i<b->core.l_qseq;i++) {
      seq[i]=seq_nt16_str[bam_seqi(bam_get_seq(b),i)];
    }
    RETVAL = newSVpv(seq,b->core.l_qseq);
    Safefree(seq);
#line 1242 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment__qscore); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment__qscore)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::_qscore",
			"b", "Bio::DB::HTS::Alignment")
;
#line 632 "lib/Bio/DB/HTS.xs"
    RETVAL = newSVpv(bam_get_qual(b),b->core.l_qseq);
#line 1271 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mtid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mtid)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mtid",
			"b", "Bio::DB::HTS::Alignment")
;
#line 641 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.mtid = SvIV(ST(1));
    RETVAL=b->core.mtid;
#line 1303 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mpos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mpos",
			"b", "Bio::DB::HTS::Alignment")
;
#line 652 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.mpos = SvIV(ST(1));
    RETVAL=b->core.mpos;
#line 1334 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_isize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_isize)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::isize",
			"b", "Bio::DB::HTS::Alignment")
;
#line 663 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.isize = SvIV(ST(1));
    RETVAL=b->core.isize;
#line 1365 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_aux); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_aux)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::l_aux",
			"b", "Bio::DB::HTS::Alignment")
;
#line 674 "lib/Bio/DB/HTS.xs"
    RETVAL=SvIV(newSViv(bam_get_l_aux(b)));
#line 1394 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 682 "lib/Bio/DB/HTS.xs"
   uint8_t *s;
   uint8_t type, key[2];
   char    str[8192];
#line 1413 "lib/Bio/DB/HTS.c"
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux",
			"b", "Bio::DB::HTS::Alignment")
;
#line 686 "lib/Bio/DB/HTS.xs"
   s = bam_get_aux(b);
   str[0] = '\0';

   int left  = sizeof(str) - strlen(str);
   while (left > 0 && (s < b->data + b->l_data)) {
        char* d   = str+strlen(str);

	key[0] = s[0];
	key[1] = s[1];
 	left -= snprintf(d, left, "%c%c:", key[0], key[1]);

	d    += 3;
	s    += 2;
	type = *s++;

	if (left <= 0) continue;

	if (type == 'A')      { left -= snprintf(d, left, "A:%c", *s);           s++; }
	else if (type == 'C') { left -= snprintf(d, left, "i:%u", *s);           s++; }
	else if (type == 'c') { left -= snprintf(d, left, "i:%d", *s);           s++; }
	else if (type == 'S') { left -= snprintf(d, left, "i:%u", *(uint16_t*)s);s += 2; }
	else if (type == 's') { left -= snprintf(d, left, "i:%d", *(int16_t*)s); s += 2; }
	else if (type == 'I') { left -= snprintf(d, left, "i:%u", *(uint32_t*)s);s += 4; }
	else if (type == 'i') { left -= snprintf(d, left, "i:%d", *(int32_t*)s); s += 4; }
	else if (type == 'f') { left -= snprintf(d, left, "f:%g", *(float*)s);   s += 4; }
	else if (type == 'd') { left -= snprintf(d, left, "d:%lg", *(double*)s); s += 8; }
	else if (type == 'Z' || type == 'H') { left -= snprintf(d, left, "%c:", type);
	                                       strncat(d,s,left);
					       while (*s++) {}
					       left = sizeof(str) - strlen(str);
	                                     }
	if (left <= 0) continue;
	strncat(d,"\t",left);
	left--;
   }
   str[strlen(str)-1] = '\0';
   RETVAL = str;
#line 1464 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, tag");
    {
	Bio__DB__HTS__Alignment	b;
	char*	tag = (char *)SvPV_nolen(ST(1))
;
#line 732 "lib/Bio/DB/HTS.xs"
   int           type;
   uint8_t       *s;
#line 1484 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux_get",
			"b", "Bio::DB::HTS::Alignment")
;
#line 735 "lib/Bio/DB/HTS.xs"
   s    = bam_aux_get(b,tag);
   if (s==0)
      XSRETURN_EMPTY;
   type = *s++;
   switch (type) {
   case 'c':
     RETVAL = newSViv((int32_t)*(int8_t*)s);
     break;
   case 'C':
     RETVAL = newSViv((int32_t)*(uint8_t*)s);
     break;
   case 's':
     RETVAL = newSViv((int32_t)*(int16_t*)s);
     break;
   case 'S':
     RETVAL = newSViv((int32_t)*(uint16_t*)s);
     break;
   case 'i':
     RETVAL = newSViv(*(int32_t*)s);
     break;
   case 'I':
     RETVAL = newSViv((int32_t)*(uint32_t*)s);
     break;
   case 'f':
     RETVAL = newSVnv(*(float*)s);
     break;
   case 'Z':
   case 'H':
     RETVAL = newSVpv((char*)s,0);
     break;
   case 'A':
     RETVAL = newSVpv((char*)s,1);
     break;
   default:
     XSRETURN_EMPTY;
   }
#line 1533 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_keys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_keys)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__HTS__Alignment	b;
#line 779 "lib/Bio/DB/HTS.xs"
   uint8_t *s;
   uint8_t type;
#line 1554 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux_keys",
			"b", "Bio::DB::HTS::Alignment")
;
#line 782 "lib/Bio/DB/HTS.xs"
   {
     s = bam_get_aux(b);  /* s is a khash macro */
     while (s < b->data + b->l_data) {
       XPUSHs(sv_2mortal(newSVpv(s,2)));
       s   += 2;
       type = *s++;
       if      (type == 'A') { ++s; }
       else if (type == 'C') { ++s; }
       else if (type == 'c') { ++s; }
       else if (type == 'S') { s += 2; }
       else if (type == 's') { s += 2; }
       else if (type == 'I') { s += 4; }
       else if (type == 'i') { s += 4; }
       else if (type == 'f') { s += 4; }
       else if (type == 'Z' || type == 'H') { while (*s) ++(s); ++(s); }
     }
   }
#line 1583 "lib/Bio/DB/HTS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_data)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
#line 805 "lib/Bio/DB/HTS.xs"
    STRLEN  len;
#line 1600 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::data",
			"b", "Bio::DB::HTS::Alignment")
;
#line 807 "lib/Bio/DB/HTS.xs"
    if (items > 1) {
      b->data     = SvPV(ST(1),len);
      b->l_data = len;
    }
    RETVAL=newSVpv(b->data,b->l_data);
#line 1618 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_data_len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_data_len)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::data_len",
			"b", "Bio::DB::HTS::Alignment")
;
#line 820 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->l_data = SvIV(ST(1));
    RETVAL=b->l_data;
#line 1650 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_m_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_m_data)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::m_data",
			"b", "Bio::DB::HTS::Alignment")
;
#line 831 "lib/Bio/DB/HTS.xs"
    if (items > 1) {
      b->m_data = SvIV(ST(1));
    }
    RETVAL=b->m_data;
#line 1682 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qname",
			"b", "Bio::DB::HTS::Alignment")
;
#line 843 "lib/Bio/DB/HTS.xs"
    RETVAL=newSVpv(bam_get_qname(b),0);
#line 1710 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_paired); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_paired)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::paired",
			"b", "Bio::DB::HTS::Alignment")
;
#line 852 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FPAIRED) != 0;
#line 1740 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_proper_pair); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_proper_pair)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::proper_pair",
			"b", "Bio::DB::HTS::Alignment")
;
#line 861 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FPROPER_PAIR) != 0;
#line 1769 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_unmapped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_unmapped)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::unmapped",
			"b", "Bio::DB::HTS::Alignment")
;
#line 870 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FUNMAP) != 0;
#line 1798 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_munmapped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_munmapped)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::munmapped",
			"b", "Bio::DB::HTS::Alignment")
;
#line 879 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FMUNMAP) != 0;
#line 1827 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_reversed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_reversed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::reversed",
			"b", "Bio::DB::HTS::Alignment")
;
#line 888 "lib/Bio/DB/HTS.xs"
  RETVAL=bam_is_rev(b);
#line 1856 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mreversed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mreversed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mreversed",
			"b", "Bio::DB::HTS::Alignment")
;
#line 897 "lib/Bio/DB/HTS.xs"
  RETVAL=bam_is_mrev(b);
#line 1885 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 906 "lib/Bio/DB/HTS.xs"
    int        i;
    uint32_t  *c;
    AV        *avref;
#line 1904 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::cigar",
			"b", "Bio::DB::HTS::Alignment")
;
#line 910 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    c     = bam_get_cigar(b);
    for (i=0;i<b->core.n_cigar;i++)
      av_push(avref, newSViv(c[i]));
    RETVAL = (SV*) newRV((SV*)avref);
#line 1922 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_new)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=Bio::DB::HTS::Header");
    {
	Bio__DB__HTS__Header	RETVAL;
#line 924 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_hdr_init();
#line 1940 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_n_targets); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_n_targets)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::n_targets",
			"bamh", "Bio::DB::HTS::Header")
;
#line 933 "lib/Bio/DB/HTS.xs"
    RETVAL = bamh->n_targets;
#line 1974 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_target_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_target_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
#line 942 "lib/Bio/DB/HTS.xs"
    int i;
    AV * avref;
#line 1992 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::target_name",
			"bamh", "Bio::DB::HTS::Header")
;
#line 945 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
      av_push(avref, newSVpv(bamh->target_name[i],0));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2009 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_target_len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_target_len)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
#line 957 "lib/Bio/DB/HTS.xs"
    int i;
    AV * avref;
#line 2028 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::target_len",
			"bamh", "Bio::DB::HTS::Header")
;
#line 960 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
       av_push(avref, newSViv(bamh->target_len[i]));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2045 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_text); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_text)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "bamh, ...");
    {
	Bio__DB__HTS__Header	bamh;
#line 971 "lib/Bio/DB/HTS.xs"
    char   *newtext;
    STRLEN n;
#line 2064 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::text",
			"bamh", "Bio::DB::HTS::Header")
;
#line 974 "lib/Bio/DB/HTS.xs"
    /* in case text is not null terminated, we copy it */
    RETVAL = newSVpv(bamh->text,bamh->l_text);
    if (items > 1) {
      newtext = (char*) SvPV(ST(1),n);
      strcpy(bamh->text,newtext);
      bamh->l_text = n;
    }
#line 2084 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_parse_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_parse_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bamh, region");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__HTS__Header	bamh;
	char*	region = (char *)SvPV_nolen(ST(1))
;
#line 991 "lib/Bio/DB/HTS.xs"
       int seqid,start,end;
#line 2106 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::parse_region",
			"bamh", "Bio::DB::HTS::Header")
;
#line 993 "lib/Bio/DB/HTS.xs"
    {
      bam_parse_region(bamh,
		       region,
		       &seqid,
		       &start,
		       &end);
      if (seqid < 0)
	XSRETURN_EMPTY;
      else {
	EXTEND(sp,3);
	PUSHs(sv_2mortal(newSViv(seqid)));
	PUSHs(sv_2mortal(newSViv(start)));
	PUSHs(sv_2mortal(newSViv(end)));
      }
    }
#line 2133 "lib/Bio/DB/HTS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Bio__DB__HTS__Header_view1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_view1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bamh, alignment");
    {
	Bio__DB__HTS__Header	bamh;
	Bio__DB__HTS__Alignment	alignment;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::view1",
			"bamh", "Bio::DB::HTS::Header")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    alignment = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Header::view1",
			"alignment", "Bio::DB::HTS::Alignment")
;
#line 1015 "lib/Bio/DB/HTS.xs"
       bam_view1(bamh,alignment);
#line 2171 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Header_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Header::DESTROY",
			"bamh")
;
#line 1023 "lib/Bio/DB/HTS.xs"
    bam_hdr_destroy(bamh);
#line 2197 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Index_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_fetch)
{
    dVAR; dXSARGS;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	CV*	callback;
	SV*	callbackdata;
#line 1039 "lib/Bio/DB/HTS.xs"
  fetch_callback_data fcd;
#line 2222 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::fetch",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::fetch",
			"hfp", "Bio::DB::HTSfile")
;

	STMT_START {
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = ST(5);
		SvGETMAGIC(xsub_tmp_sv);
                callback = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!callback) {
		    Perl_croak(aTHX_ "%s: %s is not a CODE reference",
				"Bio::DB::HTS::Index::fetch",
				"callback");
		}
	} STMT_END
;

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6)
;
	}
#line 1041 "lib/Bio/DB/HTS.xs"
  {
    fcd.callback = (SV*) callback;
    fcd.data     = callbackdata;
    RETVAL = hts_fetch(hfp,bai,ref,start,end,&fcd,hts_fetch_fun);
  }
#line 2272 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Index_pileup); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_pileup)
{
    dVAR; dXSARGS;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	CV*	callback;
	SV*	callbackdata;
#line 1060 "lib/Bio/DB/HTS.xs"
  fetch_callback_data fcd;
  hts_plbuf_t        *pileup;
#line 2299 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::pileup",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::pileup",
			"hfp", "Bio::DB::HTSfile")
;

	STMT_START {
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = ST(5);
		SvGETMAGIC(xsub_tmp_sv);
                callback = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!callback) {
		    Perl_croak(aTHX_ "%s: %s is not a CODE reference",
				"Bio::DB::HTS::Index::pileup",
				"callback");
		}
	} STMT_END
;

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6)
;
	}
#line 1063 "lib/Bio/DB/HTS.xs"
  fcd.callback = (SV*) callback;
  fcd.data     = callbackdata;
  pileup       = hts_plbuf_init(invoke_pileup_callback_fun,(void*)&fcd);
  bam_plp_set_maxcnt(pileup->iter,MaxPileupCnt);
  hts_fetch(hfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
  hts_plbuf_push(NULL,pileup);
  hts_plbuf_destroy(pileup);
#line 2349 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Index_coverage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_coverage)
{
    dVAR; dXSARGS;
    if (items < 5 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, bins=0, maxcnt=8000");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	int	bins;
	int	maxcnt;
#line 1081 "lib/Bio/DB/HTS.xs"
    coverage_graph  cg;
    hts_plbuf_t    *pileup;
    AV*             array;
    SV*             cov;
    int             i;
    bam_hdr_t      *bh;
#line 2379 "lib/Bio/DB/HTS.c"
	AV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::coverage",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::coverage",
			"hfp", "Bio::DB::HTSfile")
;

	if (items < 6)
	    bins = 0;
	else {
	    bins = (int)SvIV(ST(5))
;
	}

	if (items < 7)
	    maxcnt = 8000;
	else {
	    maxcnt = (int)SvIV(ST(6))
;
	}
#line 1088 "lib/Bio/DB/HTS.xs"
  {
      /* TODO:can we do away with this check by a move to CSI as the standard for BAM indices */
      if (end >= BAM_MAX_REGION)
      {
        if( hfp->format.format == bam ) //enum value from htsExactFormat from hts.h
        {
          bgzf_seek(hfp->fp.bgzf,0,0);
          bh = sam_hdr_read(hfp);
          end = bh->target_len[ref];
          bam_hdr_destroy(bh);
        }
      }
      if ((bins==0) || (bins > (end-start)))
         bins = end-start;

      /* coverage graph used to communicate to our callback
	  the region we are sampling */
      cg.start = start;
      cg.end   = end;
      cg.reads = 0;
      cg.width = ((double)(end-start))/bins;
      Newxz(cg.bin,bins+1,int);

      /* accumulate coverage into the coverage graph */
      pileup   = hts_plbuf_init(coverage_from_pileup_fun,(void*)&cg);
      if (items >= 7)
            bam_plp_set_maxcnt(pileup->iter,maxcnt);
      else
            bam_plp_set_maxcnt(pileup->iter,MaxPileupCnt);
      hts_fetch(hfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
      hts_plbuf_push(NULL,pileup);
      hts_plbuf_destroy(pileup);

      /* now normalize to coverage/bp and convert into an array */
      array = newAV();
      av_extend(array,bins);
      for  (i=0;i<bins;i++)
           av_store(array,i,newSVnv(((float)cg.bin[i])/cg.width));
      Safefree(cg.bin);
      RETVAL = array;
      sv_2mortal((SV*)RETVAL);  /* this fixes a documented bug in perl typemap */
  }
#line 2458 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Index_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hts_idx");
    {
	Bio__DB__HTS__Index	hts_idx;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hts_idx = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Index::close",
			"hts_idx", "Bio::DB::HTS::Index")
;
#line 1138 "lib/Bio/DB/HTS.xs"
    hts_idx_destroy(hts_idx) ;
#line 2490 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_qpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_qpos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::qpos",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1148 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->qpos;
#line 2518 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_pos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::pos",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1156 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->qpos+1;
#line 2547 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_indel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_indel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::indel",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1164 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->indel;
#line 2576 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_level); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_level)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::level",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1172 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->level;
#line 2605 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_del); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_del)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_del",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1180 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_del;
#line 2634 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_refskip); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_refskip)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_refskip",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1188 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_refskip;
#line 2663 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_head); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_head)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_head",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1196 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_head;
#line 2692 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_tail); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_tail)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_tail",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1204 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_tail;
#line 2721 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_b); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_b)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::b",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1212 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_dup1(pl->b);
#line 2749 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_alignment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_alignment)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::alignment",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1220 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_dup1(pl->b);
#line 2782 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_open)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fname");
    {
	char *	fname = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTS__Tabix	RETVAL;
#line 1232 "lib/Bio/DB/HTS.xs"
    RETVAL = tbx_index_load(fname);
#line 2806 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Tabix", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "t");
    {
	Bio__DB__HTS__Tabix	t;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_close",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1241 "lib/Bio/DB/HTS.xs"
    tbx_destroy(t);
#line 2838 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_query); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_query)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "t, region");
    {
	Bio__DB__HTS__Tabix	t;
	char *	region = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__Tabix__Iterator	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_query",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1249 "lib/Bio/DB/HTS.xs"
    RETVAL = tbx_itr_querys(t, region);
#line 2867 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Tabix::Iterator", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_header); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_header)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fp, tabix");
    {
	Bio__DB__HTSfile	fp;
	Bio__DB__HTS__Tabix	tabix;
#line 1260 "lib/Bio/DB/HTS.xs"
    int num_header_lines = 0;
    AV *av_ref;
    kstring_t str = {0,0,0};
#line 2892 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_header",
			"fp", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    tabix = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_header",
			"tabix", "Bio::DB::HTS::Tabix")
;
#line 1264 "lib/Bio/DB/HTS.xs"
    av_ref = newAV();
    while ( hts_getline(fp, KS_SEP_LINE, &str) >= 0 ) {
        if ( ! str.l ) break; //no lines left so we are done
        if ( str.s[0] != tabix->conf.meta_char ) break;

        //the line begins with a # so add it to the array
        ++num_header_lines;
        av_push(av_ref, newSVpv(str.s, str.l));
    }

    if ( ! num_header_lines )
        XSRETURN_EMPTY;

    RETVAL = newRV_noinc((SV*) av_ref);
    free(str.s);
#line 2930 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_seqnames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_seqnames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "t");
    {
	Bio__DB__HTS__Tabix	t;
#line 1286 "lib/Bio/DB/HTS.xs"
    const char **names;
    int i, num_seqs;
    AV *av_ref;
#line 2950 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_seqnames",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1290 "lib/Bio/DB/HTS.xs"
    names = tbx_seqnames(t, &num_seqs); //call actual tabix method

    //blast all the values onto a perl array
    av_ref = newAV();
    for (i = 0; i < num_seqs; ++i) {
        SV *sv_ref = newSVpv(names[i], 0);
        av_push(av_ref, sv_ref);
    }

    free(names);

    //return a reference to our array
    RETVAL = newRV_noinc((SV*)av_ref);
#line 2976 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "iter, fp, t");
    {
	Bio__DB__HTS__Tabix__Iterator	iter;
	Bio__DB__HTSfile	fp;
	Bio__DB__HTS__Tabix	t;
#line 1314 "lib/Bio/DB/HTS.xs"
    kstring_t str = {0,0,0};
#line 2996 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__Tabix__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"iter", "Bio::DB::HTS::Tabix::Iterator")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    fp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"fp", "Bio::DB::HTSfile")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1316 "lib/Bio/DB/HTS.xs"
    if (tbx_itr_next(fp, t, iter, &str) < 0) {
        free(str.s);
        XSRETURN_EMPTY;
    }

    RETVAL = newSVpv(str.s, str.l);
    free(str.s);

#line 3037 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "iter");
    {
	Bio__DB__HTS__Tabix__Iterator	iter;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__Tabix__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_free",
			"iter", "Bio::DB::HTS::Tabix::Iterator")
;
#line 1331 "lib/Bio/DB/HTS.xs"
	tbx_itr_destroy(iter);
#line 3065 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_open)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "packname, filename, mode=\"r\"");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	char*	filename = (char *)SvPV_nolen(ST(1))
;
	char*	mode;
	Bio__DB__HTS__VCFfile	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 1343 "lib/Bio/DB/HTS.xs"
      RETVAL = bcf_open(filename, mode);
#line 3093 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCFfile", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_header_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_header_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vfile");
    {
	Bio__DB__HTS__VCFfile	vfile;
#line 1352 "lib/Bio/DB/HTS.xs"
        bcf_hdr_t* h;
#line 3115 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::header_read",
			"vfile", "Bio::DB::HTS::VCFfile")
;
#line 1354 "lib/Bio/DB/HTS.xs"
        h = bcf_hdr_read(vfile);
        RETVAL = h;
#line 3130 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_read1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_read1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "vfile, header");
    {
	Bio__DB__HTS__VCFfile	vfile;
	Bio__DB__HTS__VCF__Header	header;
#line 1365 "lib/Bio/DB/HTS.xs"
        bcf1_t *rec;
#line 3153 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Row	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::read1",
			"vfile", "Bio::DB::HTS::VCFfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::read1",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1367 "lib/Bio/DB/HTS.xs"
        rec = bcf_init();
        if ( bcf_read(vfile, header, rec) == 0 )
        {
            bcf_unpack(rec, BCF_UN_ALL) ;
            RETVAL = rec ;
        }
        else
        {
            XSRETURN_EMPTY;
        }
#line 3186 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Row", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_num_variants); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_num_variants)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	char*	filename = (char *)SvPV_nolen(ST(1))
;
#line 1387 "lib/Bio/DB/HTS.xs"
        int n_records = 0;
        vcfFile* vfile;
        bcf_hdr_t* h;
        bcf1_t *rec;
#line 3214 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;
#line 1392 "lib/Bio/DB/HTS.xs"
        vfile = bcf_open(filename, "r");
        h = bcf_hdr_read(vfile);
        rec = bcf_init();

        //loop through all the lines but don't do anything with them
        while(bcf_read(vfile, h, rec) == 0)
        {
            ++n_records;
        }
        bcf_close(vfile) ;
        RETVAL = newSViv(n_records);
#line 3228 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_vcf_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_vcf_close)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "vfile, h");
    {
	Bio__DB__HTS__VCFfile	vfile;
	Bio__DB__HTS__VCF__Header	h;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::vcf_close",
			"vfile", "Bio::DB::HTS::VCFfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    h = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::vcf_close",
			"h", "Bio::DB::HTS::VCF::Header")
;
#line 1413 "lib/Bio/DB/HTS.xs"
        bcf_hdr_destroy(h);
        bcf_close(vfile);
#line 3268 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_version)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1424 "lib/Bio/DB/HTS.xs"
#line 3283 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::version",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1425 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(bcf_hdr_get_version(header),0) ;
#line 3297 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_samples); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_samples)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1434 "lib/Bio/DB/HTS.xs"
#line 3314 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::num_samples",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1435 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_hdr_nsamples(header) ;
#line 3329 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_sample_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_sample_names)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1444 "lib/Bio/DB/HTS.xs"
        int nsamples = 0 ;
        int i ;
        AV *av_ref;
#line 3348 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::get_sample_names",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1448 "lib/Bio/DB/HTS.xs"
        av_ref = newAV();
        nsamples = bcf_hdr_nsamples(header) ;
        for (i=0 ; i<nsamples ; i++)
        {
            SV *sv_ref = newSVpv(header->samples[i], 0);
            av_push(av_ref, sv_ref);
        }
        RETVAL = newRV_noinc((SV*)av_ref);
#line 3369 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_seqnames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_seqnames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1463 "lib/Bio/DB/HTS.xs"
        int nseq = 0 ;
#line 3387 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::num_seqnames",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1465 "lib/Bio/DB/HTS.xs"
     bcf_hdr_seqnames(header, &nseq);
     RETVAL = nseq;
#line 3403 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_seqnames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_seqnames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1475 "lib/Bio/DB/HTS.xs"
        int nseq = 0 ;
        const char **seqnames ;
        int i = 0 ;
        AV *av_ref = newAV() ;
#line 3423 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::get_seqnames",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1480 "lib/Bio/DB/HTS.xs"
        seqnames = bcf_hdr_seqnames(header, &nseq);
        for (i = 0; i < nseq; i++)
        {
            SV *sv_ref = newSVpv(seqnames[i], 0);
            av_push(av_ref, sv_ref);
        }
        free(seqnames) ;
        RETVAL = newRV_noinc((SV*)av_ref);
#line 3444 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_print); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_print)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1502 "lib/Bio/DB/HTS.xs"
     int i ;
#line 3463 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::print",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::print",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1504 "lib/Bio/DB/HTS.xs"
     printf("\nVCF data line:\n");
     printf("chromosome:%s\t", bcf_hdr_id2name(header,row->rid));
     printf("position:%d\t", (row->pos+1));
     printf("QUAL:%f\t", row->qual);
     printf("ID:%s\t", row->d.id );
     printf("REF:%s\n", row->d.als);
     printf("Num Alleles:%d\n", row->n_allele-1);
     for( i=1 ; i<row->n_allele ; i++ )
     {
       printf("ALT[%d]=%s\t", i, row->d.allele[i]);
     }
     printf("\nNum Filters:%d\n", row->d.n_flt);

#line 3498 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_chromosome); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_chromosome)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1527 "lib/Bio/DB/HTS.xs"
#line 3514 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::chromosome",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::chromosome",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1528 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(bcf_hdr_id2name(header,row->rid),0) ;
#line 3538 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_position); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_position)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1537 "lib/Bio/DB/HTS.xs"
#line 3555 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::position",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1538 "lib/Bio/DB/HTS.xs"
     RETVAL = row->pos+1;
#line 3570 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_quality); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_quality)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1546 "lib/Bio/DB/HTS.xs"
#line 3586 "lib/Bio/DB/HTS.c"
	float	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::quality",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1547 "lib/Bio/DB/HTS.xs"
     RETVAL = row->qual;
#line 3601 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1556 "lib/Bio/DB/HTS.xs"
#line 3617 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::id",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1557 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(row->d.id, 0) ;
#line 3631 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_reference); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_reference)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1565 "lib/Bio/DB/HTS.xs"
#line 3648 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::reference",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1566 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(row->d.als, 0) ;
#line 3662 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_alleles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_alleles)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1575 "lib/Bio/DB/HTS.xs"
#line 3679 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::num_alleles",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1576 "lib/Bio/DB/HTS.xs"
     RETVAL = row->n_allele-1 ;
#line 3694 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_alleles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_alleles)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1585 "lib/Bio/DB/HTS.xs"
     int i;
     AV *av_ref;
#line 3712 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_alleles",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1588 "lib/Bio/DB/HTS.xs"
     av_ref = newAV();
     for (i = 1; i < row->n_allele; ++i) {
        SV *sv_ref = newSVpv(row->d.allele[i], 0);
        av_push(av_ref, sv_ref);
     }
     RETVAL = newRV_noinc((SV*)av_ref);
#line 3731 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_filters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_filters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1601 "lib/Bio/DB/HTS.xs"
#line 3748 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::num_filters",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1602 "lib/Bio/DB/HTS.xs"
     RETVAL = row->d.n_flt ;
#line 3763 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_has_filter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_has_filter)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, filter");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	filter = (char *)SvPV_nolen(ST(2))
;
#line 1612 "lib/Bio/DB/HTS.xs"
#line 3782 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::has_filter",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::has_filter",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1613 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_has_filter(header,row,filter) ;
#line 3807 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_is_snp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_is_snp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1622 "lib/Bio/DB/HTS.xs"
#line 3823 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::is_snp",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1623 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_is_snp(row) ;
#line 3838 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_variant_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_variant_type)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, allele_index");
    {
	Bio__DB__HTS__VCF__Row	row;
	int	allele_index = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_variant_type",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1633 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_get_variant_type(row, allele_index);
#line 3869 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info_type)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2))
;
#line 1644 "lib/Bio/DB/HTS.xs"
      bcf_info_t* info ;
#line 3889 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info_type",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info_type",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1646 "lib/Bio/DB/HTS.xs"
      info = bcf_get_info(header, row, id);
      if( info == NULL )
      {
        RETVAL = newSVpv("",0);
      }
      else
      {
        switch( info->type )
        {
          case BCF_BT_FLOAT:
               RETVAL = newSVpv("Float",0);
               break ;
          case BCF_BT_NULL:
               RETVAL = newSVpv("Flag",0);
               break ;
          case BCF_BT_CHAR:
               RETVAL = newSVpv("String",0);
               break ;
          default:
               RETVAL = newSVpv("Integer",0);
        }
      }
#line 3934 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2))
;
#line 1678 "lib/Bio/DB/HTS.xs"
      bcf_info_t* info ;
      int i=0 ;
      int strlength=0 ;
      int* buf_i;
      float* buf_f;
      char* buf_c;
      AV* av_ref;
      int result;
#line 3962 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1687 "lib/Bio/DB/HTS.xs"
      info = bcf_get_info(header, row, id);
      if( info == NULL )
      {
          // info null, nothing to return
          RETVAL = newSVpv("ID_NOT_FOUND",0);
      }
      else
      {
        av_ref = newAV();
        if( info->type == BCF_BT_NULL )
        {
          buf_i = calloc(1, sizeof(int)) ;
          result = bcf_get_info_flag(header,row,id,&buf_i,&(info->len));
          if( result == 1 )
          {
            av_push(av_ref, newSViv(1));
          }
          else
          {
            av_push(av_ref, newSViv(0));
          }
          free(buf_i);
        }
        else if( info->type == BCF_BT_FLOAT )
        {
          buf_f = calloc(info->len, sizeof(float));
          result = bcf_get_info_float(header, row, id, &buf_f, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSVnv(buf_f[i])) ;
          }
          free(buf_f);
        }
        else if( info->type == BCF_BT_CHAR )
        {
          strlength = info->len+1 ;
          buf_c = calloc(strlength, sizeof(char));
          result = bcf_get_info_string(header,row,id,&buf_c,&strlength) ;
          buf_c[info->len] = '\0' ;
          av_push(av_ref, newSVpv(buf_c,0));
          free(buf_c);
        }
        else if( info->type == BCF_BT_INT32 )
        {
          buf_i = calloc(info->len, sizeof(int));
          result = bcf_get_info_int32(header, row, id, &buf_i, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( info->type == BCF_BT_INT16 )
        {
          buf_i = calloc(info->len, sizeof(int));
          result = bcf_get_info_int32(header, row, id, &buf_i, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( info->type == BCF_BT_INT8 )
        {
          buf_i = calloc(info->len, sizeof(int));
          result = bcf_get_info_int32(header, row, id, &buf_i, &(info->len)) ;
          for( i=0 ; i<result ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        //return a reference to our array
        RETVAL = newRV_noinc((SV*)av_ref);
      }

#line 4061 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format_type)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2))
;
#line 1775 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt ;
#line 4082 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format_type",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format_type",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1777 "lib/Bio/DB/HTS.xs"
      fmt = bcf_get_fmt(header, row, id);
      if( fmt == NULL )
      {
        RETVAL = newSVpv("",0);
      }
      else
      {
        switch( fmt->type )
        {
          case BCF_BT_FLOAT:
               RETVAL = newSVpv("Float",0);
               break ;
          case BCF_BT_CHAR:
               RETVAL = newSVpv("String",0);
               break ;
          default:
               RETVAL = newSVpv("Integer",0);
        }
      }
#line 4124 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2))
;
#line 1806 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt ;
      int i ;
      int* buf_i = NULL ;
      float* buf_f = NULL ;
      char* buf_c = NULL ;
      AV* av_ref;
      int ndst = 0 ;
      int result;
#line 4152 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1815 "lib/Bio/DB/HTS.xs"
      fmt = bcf_get_fmt(header, row, id);
      if( fmt == NULL )
      {
          // info null, nothing to return
          RETVAL = newSVpv("ID_NOT_FOUND",0);
      }
      else
      {
        av_ref = newAV();

        if( fmt->type == BCF_BT_FLOAT )
        {
          result = bcf_get_format_float(header, row, id, &buf_f, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSVnv(buf_f[i])) ;
          }
          free(buf_f);
        }
        else if( fmt->type == BCF_BT_CHAR )
        {
          result = bcf_get_format_char(header,row,id,&buf_c,&ndst) ;
          av_push(av_ref, newSVpv(buf_c, ndst+1));
          free(buf_c);
        }
        else if( fmt->type == BCF_BT_INT32 )
        {
          result = bcf_get_format_int32(header, row, id, &buf_i, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( fmt->type == BCF_BT_INT16 )
        {
          result = bcf_get_format_int32(header, row, id, &buf_i, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        else if( fmt->type == BCF_BT_INT8 )
        {
          result = bcf_get_format_int32(header, row, id, &buf_i, &ndst) ;
          for( i=0 ; i<ndst ; i++ )
          {
            av_push(av_ref, newSViv(buf_i[i])) ;
          }
          free(buf_i);
        }
        //return a reference to our array
        RETVAL = newRV_noinc((SV*)av_ref);
      }

#line 4231 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_genotypes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_genotypes)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1881 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt ;
      int ngt ;
      int* gt_arr = NULL ;
      int ngt_arr = 0;
      AV* av_ref;
      int i=0 ;
#line 4255 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_genotypes",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_genotypes",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1888 "lib/Bio/DB/HTS.xs"
      av_ref = newAV();
      /* Note the VCF header type treats this as a String but BCF treats as an int */
      ngt = bcf_get_genotypes(header, row, &gt_arr, &ngt_arr);
      for( i=0 ; i<ngt_arr ; i++ )
      {
        av_push(av_ref, newSViv(gt_arr[i])) ;
      }
      free(gt_arr);
      RETVAL = newRV_noinc((SV*)av_ref);
#line 4287 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_destroy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_destroy)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, row");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTS__VCF__Row	row;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::destroy",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1909 "lib/Bio/DB/HTS.xs"
      bcf_destroy(row);
#line 4317 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_open)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "filename");
    {
	char*	filename = (char *)SvPV_nolen(ST(0))
;
#line 1920 "lib/Bio/DB/HTS.xs"
        bcf_sweep_t* sweep;
#line 4334 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Sweep	RETVAL;
#line 1922 "lib/Bio/DB/HTS.xs"
        sweep = bcf_sweep_init(filename);
        RETVAL = sweep;
#line 4339 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Sweep", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_header_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_header_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 1931 "lib/Bio/DB/HTS.xs"
        bcf_hdr_t* h;
#line 4361 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::header_read",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 1933 "lib/Bio/DB/HTS.xs"
        h = bcf_sweep_hdr(sweep);
        RETVAL = h;
#line 4376 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_next)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 1942 "lib/Bio/DB/HTS.xs"
        bcf1_t* line;
#line 4398 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Row	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_next",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 1944 "lib/Bio/DB/HTS.xs"
        line = bcf_sweep_fwd(sweep);
        if( line )
        {
          RETVAL = line;
        }
        else
        {
          XSRETURN_EMPTY ;
        }
#line 4420 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Row", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_previous); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_previous)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 1960 "lib/Bio/DB/HTS.xs"
        bcf1_t* line;
#line 4442 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Row	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_previous",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 1962 "lib/Bio/DB/HTS.xs"
        line = bcf_sweep_bwd(sweep);
        if( line )
        {
          RETVAL = line;
        }
        else
        {
          XSRETURN_EMPTY ;
        }
#line 4464 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Row", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_close",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 1978 "lib/Bio/DB/HTS.xs"
        bcf_sweep_destroy(sweep);
#line 4496 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_new)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "package, filename, mode=\"r\"");
    {
	char *	package = (char *)SvPV_nolen(ST(0))
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	char *	mode;
	Bio__DB__HTS__Kseq	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 1991 "lib/Bio/DB/HTS.xs"
      RETVAL = gzopen(filename, mode);
#line 4524 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_newfh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_newfh)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "pack, fh, mode=\"r\"");
    {
	char *	pack = (char *)SvPV_nolen(ST(0))
;
	PerlIO*	fh = IoIFP(sv_2io(ST(1)))
;
	char *	mode;
	Bio__DB__HTS__Kseq	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 2002 "lib/Bio/DB/HTS.xs"
      RETVAL = gzdopen(PerlIO_fileno(fh), mode);
#line 4558 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_iterator); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_iterator)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fp");
    {
	Bio__DB__HTS__Kseq	fp;
	Bio__DB__HTS__Kseq__Iterator	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::iterator",
			"fp", "Bio::DB::HTS::Kseq")
;
#line 2011 "lib/Bio/DB/HTS.xs"
      RETVAL = kseq_init(fp);
#line 4591 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq::Iterator", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fp");
    {
	Bio__DB__HTS__Kseq	fp;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::DESTROY",
			"fp")
;
#line 2020 "lib/Bio/DB/HTS.xs"
      gzclose(fp);
#line 4623 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "package, fh");
    {
	char *	package = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTS__Kseq	fh;
	Bio__DB__HTS__Kseq__Kstream	RETVAL;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Kseq")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    fh = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::new",
			"fh", "Bio::DB::HTS::Kseq")
;
#line 2030 "lib/Bio/DB/HTS.xs"
      RETVAL = ks_init(fh);
#line 4652 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq::Kstream", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_begin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_begin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::begin",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2039 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->begin;
#line 4686 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::end",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2048 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->end;
#line 4715 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_is_eof); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_is_eof)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::is_eof",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2057 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->is_eof;
#line 4744 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_buffer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_buffer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::buffer",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2066 "lib/Bio/DB/HTS.xs"
      RETVAL = (char *)kstr->buf;
#line 4773 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_fh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_fh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	Bio__DB__HTS__Kseq	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::fh",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2075 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->f;
#line 4801 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::Kstream::DESTROY",
			"kstr")
;
#line 2084 "lib/Bio/DB/HTS.xs"
      ks_destroy(kstr);
#line 4833 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::next_seq_hash",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2093 "lib/Bio/DB/HTS.xs"
      HV * results;
#line 4860 "lib/Bio/DB/HTS.c"
#line 2095 "lib/Bio/DB/HTS.xs"
      results = (HV *)sv_2mortal((SV *)newHV());
      if (kseq_read(it) >= 0) {
          hv_stores(results, "name", newSVpvn(it->name.s, it->name.l));
          hv_stores(results, "desc", newSVpvn(it->comment.s, it->comment.l));
          hv_stores(results, "seq", newSVpvn(it->seq.s, it->seq.l));
          hv_stores(results, "qual", newSVpvn(it->qual.s, it->qual.l));
          RETVAL = newRV((SV *)results);
      } else {
          XSRETURN_UNDEF;
      }
#line 4872 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::next_seq",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2113 "lib/Bio/DB/HTS.xs"
    HV * results;
    HV * class_stash;
    SV * ref;
#line 4903 "lib/Bio/DB/HTS.c"
#line 2117 "lib/Bio/DB/HTS.xs"
    results = (HV *)sv_2mortal((SV *)newHV());
    class_stash = gv_stashpv("Bio::DB::HTS::Kseq::Record", 0);
    if (kseq_read(it) >= 0) {
        hv_stores(results, "name", newSVpvn(it->name.s, it->name.l));
        hv_stores(results, "desc", newSVpvn(it->comment.s, it->comment.l));
        hv_stores(results, "seq", newSVpvn(it->seq.s, it->seq.l));
        hv_stores(results, "qual", newSVpvn(it->qual.s, it->qual.l));
        ref = newRV((SV *)results);
        sv_bless(ref, class_stash);
        RETVAL = ref;
    } else {
        XSRETURN_UNDEF;
    }
#line 4918 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::read",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2138 "lib/Bio/DB/HTS.xs"
#line 4947 "lib/Bio/DB/HTS.c"
#line 2139 "lib/Bio/DB/HTS.xs"
      RETVAL = kseq_read(it);
#line 4950 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_rewind); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_rewind)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::rewind",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2148 "lib/Bio/DB/HTS.xs"
      /* kseq_rewind() doesn't completely rewind the file,
        just resets markers */
      kseq_rewind(it);
      /* use zlib to do so */
      gzrewind(it->f->f);
#line 4981 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_kstream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_kstream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	Bio__DB__HTS__Kseq__Kstream	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::kstream",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2159 "lib/Bio/DB/HTS.xs"
      RETVAL = it->f;
#line 5008 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq::Kstream", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::name",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2168 "lib/Bio/DB/HTS.xs"
      RETVAL = it->name.s;
#line 5042 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_comment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_comment)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::comment",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2177 "lib/Bio/DB/HTS.xs"
      RETVAL = it->comment.s;
#line 5071 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_seq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_seq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::seq",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2186 "lib/Bio/DB/HTS.xs"
      RETVAL = it->seq.s;
#line 5100 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_qual); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_qual)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::qual",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2195 "lib/Bio/DB/HTS.xs"
      RETVAL = it->qual.s;
#line 5129 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_last_char); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_last_char)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::last_char",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2204 "lib/Bio/DB/HTS.xs"
      RETVAL = it->last_char;
#line 5158 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::Iterator::DESTROY",
			"it")
;
#line 2213 "lib/Bio/DB/HTS.xs"
      kseq_destroy(it);
#line 5185 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Bio__DB__HTS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Bio__DB__HTS)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("Bio::DB::HTS::Fai::load", XS_Bio__DB__HTS__Fai_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::destroy", XS_Bio__DB__HTS__Fai_destroy, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::fetch", XS_Bio__DB__HTS__Fai_fetch, file, "$$$");
        newXS_deffile("Bio::DB::HTSfile::max_pileup_cnt", XS_Bio__DB__HTSfile_max_pileup_cnt);
        (void)newXSproto_portable("Bio::DB::HTSfile::open", XS_Bio__DB__HTSfile_open, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::close", XS_Bio__DB__HTSfile_close, file, "$");
        newXS_deffile("Bio::DB::HTSfile::index_build", XS_Bio__DB__HTSfile_index_build);
        (void)newXSproto_portable("Bio::DB::HTSfile::index_load", XS_Bio__DB__HTSfile_index_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::index_close", XS_Bio__DB__HTSfile_index_close, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::header_read", XS_Bio__DB__HTSfile_header_read, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::header_write", XS_Bio__DB__HTSfile_header_write, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::read1", XS_Bio__DB__HTSfile_read1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::new", XS_Bio__DB__HTS__Alignment_new, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::DESTROY", XS_Bio__DB__HTS__Alignment_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::tid", XS_Bio__DB__HTS__Alignment_tid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::pos", XS_Bio__DB__HTS__Alignment_pos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::calend", XS_Bio__DB__HTS__Alignment_calend, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::cigar2qlen", XS_Bio__DB__HTS__Alignment_cigar2qlen, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qual", XS_Bio__DB__HTS__Alignment_qual, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::flag", XS_Bio__DB__HTS__Alignment_flag, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::n_cigar", XS_Bio__DB__HTS__Alignment_n_cigar, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::l_qseq", XS_Bio__DB__HTS__Alignment_l_qseq, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qseq", XS_Bio__DB__HTS__Alignment_qseq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::_qscore", XS_Bio__DB__HTS__Alignment__qscore, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mtid", XS_Bio__DB__HTS__Alignment_mtid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mpos", XS_Bio__DB__HTS__Alignment_mpos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::isize", XS_Bio__DB__HTS__Alignment_isize, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::l_aux", XS_Bio__DB__HTS__Alignment_l_aux, file, "$;$");
        newXS_deffile("Bio::DB::HTS::Alignment::aux", XS_Bio__DB__HTS__Alignment_aux);
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::aux_get", XS_Bio__DB__HTS__Alignment_aux_get, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::aux_keys", XS_Bio__DB__HTS__Alignment_aux_keys, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::data", XS_Bio__DB__HTS__Alignment_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::data_len", XS_Bio__DB__HTS__Alignment_data_len, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::m_data", XS_Bio__DB__HTS__Alignment_m_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qname", XS_Bio__DB__HTS__Alignment_qname, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::paired", XS_Bio__DB__HTS__Alignment_paired, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::proper_pair", XS_Bio__DB__HTS__Alignment_proper_pair, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::unmapped", XS_Bio__DB__HTS__Alignment_unmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::munmapped", XS_Bio__DB__HTS__Alignment_munmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::reversed", XS_Bio__DB__HTS__Alignment_reversed, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mreversed", XS_Bio__DB__HTS__Alignment_mreversed, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::cigar", XS_Bio__DB__HTS__Alignment_cigar, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::new", XS_Bio__DB__HTS__Header_new, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::n_targets", XS_Bio__DB__HTS__Header_n_targets, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::target_name", XS_Bio__DB__HTS__Header_target_name, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::target_len", XS_Bio__DB__HTS__Header_target_len, file, "$");
        newXS_deffile("Bio::DB::HTS::Header::text", XS_Bio__DB__HTS__Header_text);
        (void)newXSproto_portable("Bio::DB::HTS::Header::parse_region", XS_Bio__DB__HTS__Header_parse_region, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::view1", XS_Bio__DB__HTS__Header_view1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::DESTROY", XS_Bio__DB__HTS__Header_DESTROY, file, "$");
        newXS_deffile("Bio::DB::HTS::Index::fetch", XS_Bio__DB__HTS__Index_fetch);
        newXS_deffile("Bio::DB::HTS::Index::pileup", XS_Bio__DB__HTS__Index_pileup);
        newXS_deffile("Bio::DB::HTS::Index::coverage", XS_Bio__DB__HTS__Index_coverage);
        newXS_deffile("Bio::DB::HTS::Index::close", XS_Bio__DB__HTS__Index_close);
        newXS_deffile("Bio::DB::HTS::Pileup::qpos", XS_Bio__DB__HTS__Pileup_qpos);
        newXS_deffile("Bio::DB::HTS::Pileup::pos", XS_Bio__DB__HTS__Pileup_pos);
        newXS_deffile("Bio::DB::HTS::Pileup::indel", XS_Bio__DB__HTS__Pileup_indel);
        newXS_deffile("Bio::DB::HTS::Pileup::level", XS_Bio__DB__HTS__Pileup_level);
        newXS_deffile("Bio::DB::HTS::Pileup::is_del", XS_Bio__DB__HTS__Pileup_is_del);
        newXS_deffile("Bio::DB::HTS::Pileup::is_refskip", XS_Bio__DB__HTS__Pileup_is_refskip);
        newXS_deffile("Bio::DB::HTS::Pileup::is_head", XS_Bio__DB__HTS__Pileup_is_head);
        newXS_deffile("Bio::DB::HTS::Pileup::is_tail", XS_Bio__DB__HTS__Pileup_is_tail);
        newXS_deffile("Bio::DB::HTS::Pileup::b", XS_Bio__DB__HTS__Pileup_b);
        newXS_deffile("Bio::DB::HTS::Pileup::alignment", XS_Bio__DB__HTS__Pileup_alignment);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_open", XS_Bio__DB__HTS__Tabix_tbx_open);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_close", XS_Bio__DB__HTS__Tabix_tbx_close);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_query", XS_Bio__DB__HTS__Tabix_tbx_query);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_header", XS_Bio__DB__HTS__Tabix_tbx_header);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_seqnames", XS_Bio__DB__HTS__Tabix_tbx_seqnames);
        newXS_deffile("Bio::DB::HTS::Tabix::Iterator::tbx_iter_next", XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next);
        newXS_deffile("Bio::DB::HTS::Tabix::Iterator::tbx_iter_free", XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free);
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::open", XS_Bio__DB__HTS__VCFfile_open, file, "$$$");
        newXS_deffile("Bio::DB::HTS::VCFfile::header_read", XS_Bio__DB__HTS__VCFfile_header_read);
        newXS_deffile("Bio::DB::HTS::VCFfile::read1", XS_Bio__DB__HTS__VCFfile_read1);
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::num_variants", XS_Bio__DB__HTS__VCFfile_num_variants, file, "$$$");
        newXS_deffile("Bio::DB::HTS::VCFfile::vcf_close", XS_Bio__DB__HTS__VCFfile_vcf_close);
        newXS_deffile("Bio::DB::HTS::VCF::Header::version", XS_Bio__DB__HTS__VCF__Header_version);
        newXS_deffile("Bio::DB::HTS::VCF::Header::num_samples", XS_Bio__DB__HTS__VCF__Header_num_samples);
        newXS_deffile("Bio::DB::HTS::VCF::Header::get_sample_names", XS_Bio__DB__HTS__VCF__Header_get_sample_names);
        newXS_deffile("Bio::DB::HTS::VCF::Header::num_seqnames", XS_Bio__DB__HTS__VCF__Header_num_seqnames);
        newXS_deffile("Bio::DB::HTS::VCF::Header::get_seqnames", XS_Bio__DB__HTS__VCF__Header_get_seqnames);
        newXS_deffile("Bio::DB::HTS::VCF::Row::print", XS_Bio__DB__HTS__VCF__Row_print);
        newXS_deffile("Bio::DB::HTS::VCF::Row::chromosome", XS_Bio__DB__HTS__VCF__Row_chromosome);
        newXS_deffile("Bio::DB::HTS::VCF::Row::position", XS_Bio__DB__HTS__VCF__Row_position);
        newXS_deffile("Bio::DB::HTS::VCF::Row::quality", XS_Bio__DB__HTS__VCF__Row_quality);
        newXS_deffile("Bio::DB::HTS::VCF::Row::id", XS_Bio__DB__HTS__VCF__Row_id);
        newXS_deffile("Bio::DB::HTS::VCF::Row::reference", XS_Bio__DB__HTS__VCF__Row_reference);
        newXS_deffile("Bio::DB::HTS::VCF::Row::num_alleles", XS_Bio__DB__HTS__VCF__Row_num_alleles);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_alleles", XS_Bio__DB__HTS__VCF__Row_get_alleles);
        newXS_deffile("Bio::DB::HTS::VCF::Row::num_filters", XS_Bio__DB__HTS__VCF__Row_num_filters);
        newXS_deffile("Bio::DB::HTS::VCF::Row::has_filter", XS_Bio__DB__HTS__VCF__Row_has_filter);
        newXS_deffile("Bio::DB::HTS::VCF::Row::is_snp", XS_Bio__DB__HTS__VCF__Row_is_snp);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_variant_type", XS_Bio__DB__HTS__VCF__Row_get_variant_type);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_info_type", XS_Bio__DB__HTS__VCF__Row_get_info_type);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_info", XS_Bio__DB__HTS__VCF__Row_get_info);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_format_type", XS_Bio__DB__HTS__VCF__Row_get_format_type);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_format", XS_Bio__DB__HTS__VCF__Row_get_format);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_genotypes", XS_Bio__DB__HTS__VCF__Row_get_genotypes);
        newXS_deffile("Bio::DB::HTS::VCF::Row::destroy", XS_Bio__DB__HTS__VCF__Row_destroy);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_open", XS_Bio__DB__HTS__VCF__Sweep_sweep_open);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::header_read", XS_Bio__DB__HTS__VCF__Sweep_header_read);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_next", XS_Bio__DB__HTS__VCF__Sweep_sweep_next);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_previous", XS_Bio__DB__HTS__VCF__Sweep_sweep_previous);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_close", XS_Bio__DB__HTS__VCF__Sweep_sweep_close);
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::new", XS_Bio__DB__HTS__Kseq_new, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::newfh", XS_Bio__DB__HTS__Kseq_newfh, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::iterator", XS_Bio__DB__HTS__Kseq_iterator, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::DESTROY", XS_Bio__DB__HTS__Kseq_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::new", XS_Bio__DB__HTS__Kseq__Kstream_new, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::begin", XS_Bio__DB__HTS__Kseq__Kstream_begin, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::end", XS_Bio__DB__HTS__Kseq__Kstream_end, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::is_eof", XS_Bio__DB__HTS__Kseq__Kstream_is_eof, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::buffer", XS_Bio__DB__HTS__Kseq__Kstream_buffer, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::fh", XS_Bio__DB__HTS__Kseq__Kstream_fh, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::DESTROY", XS_Bio__DB__HTS__Kseq__Kstream_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::next_seq_hash", XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::next_seq", XS_Bio__DB__HTS__Kseq__Iterator_next_seq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::read", XS_Bio__DB__HTS__Kseq__Iterator_read, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::rewind", XS_Bio__DB__HTS__Kseq__Iterator_rewind, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::kstream", XS_Bio__DB__HTS__Kseq__Iterator_kstream, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::name", XS_Bio__DB__HTS__Kseq__Iterator_name, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::comment", XS_Bio__DB__HTS__Kseq__Iterator_comment, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::seq", XS_Bio__DB__HTS__Kseq__Iterator_seq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::qual", XS_Bio__DB__HTS__Kseq__Iterator_qual, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::last_char", XS_Bio__DB__HTS__Kseq__Iterator_last_char, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::DESTROY", XS_Bio__DB__HTS__Kseq__Iterator_DESTROY, file, "$");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

